{"pages":[{"title":"关于我","text":"在校大学生，数学不太好，喜欢新事物，正在努力学习。 我是个追求从容的人，什么是从容呢？我觉得就是尽可能的把握自己的时间，让自己忙的时候不那么忙，闲的时候不那么闲，这样就可以让自己不至于奔走至狼狈，也不至于闲散到颓废，少一些无可奈何的身不由己，少一些心血来潮的浅尝辄止，这应该就是我眼中的从容吧。 生活是什么呢？生活是这样的，有的事情还没有做，一定要做的……另有些事做了，没有做好。明天不散步了。——木心《哥伦比亚的倒影》 今天还散不散步呢，还是得好好想想。","link":"/about/index.html"}],"posts":[{"title":"ESLint 入门","text":"背景最近一两年写前端项目时一直都有接触 ESLint，很多文档和博客也一直都推荐使用开发者 ESLint，但是一直以来都没有好好地学习过它。最近因为使用 Nuxt 开发时 ESLint 缓存出问题导致浪费了半个小时，我越发觉得有必要深入地了解一下这个前端开发中最常使用的代码风格规范工具了。（不得不说，Nuxt 这个框架真的有点难用。） ESLint 的用途和初衷ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。维基百科上这样解释的：lint, or a linter, is a static code analysis tool used to flag programming errors, bugs, stylistic errors, and suspicious constructs. 就是说 ESLint 是写 javascript 时用来分析静态代码是否存在语法错误、代码风格错误和可疑结构的工具。 ESLint 的配置文件配置文件基础配置文件可以使用 .js, .yaml/.yml, .json 格式的文件和 package.json 中的 eslintConfig 属性来定义。读取的优先级如下： .eslintrc.js .eslintrc.cjs .eslintrc.yaml .eslintrc.yml .eslintrc.json package.json 注：eslint 只会读取优先级最高的一个配置文件。 最重要的 rulesESLint 的配置文件通过配置检查规则来给代码做静态检查，rules 对象中的键值对都代表一个规则，规则的值是一个数组，数组的第一个值是规则的检查力度，从 0 到 2 代表检查的力度越来越严格，0 代表不提示，1 代表给出 warning，2 代表给出 error。也可以直接用力度单词表示，如”off”, “warning” 和 “error”。数组第二个及以后的值表示的是传给该规则的参数。 下面给的配置文件片段规定在项目中 1. 如果使用了分号则报错；2. 引号只能用双引号，使用了单引号就会报错。 .eslintrc.js123456module.exports = { rules: { semi: ['error', 'always'], quotes: ['error', 'double'], },} 共享规则库另外，ESLint 还可以使用其他共享规则进行扩展。在配置文件中使用 extends 即可，如下面的一行配置项表示引入了 eslint 官方推荐的规则。（官方非常推荐使用这个规则库） .eslintrc.js123module.exports = { extends: 'eslint:recommended',} 当然有 recommended 就有 all, 但官方不推荐在生产环境下使用 all 这个共享库，因为其中的核心规则会随着版本的变化而改变，会导致预料之外的情况。 引入第三方规则库会有三种效果：1. 打开相应的规则；2. 改变检查力度但是不修改其它选项；3. 直接覆盖原本的规则。 使用插件eslint 的插件其实就是一个 npm 包，可以给 eslint 提供包括但不限于加入新规则和导出共享规则的功能。如下面的配置文件就引入了 react 的 eslint 插件。 1234567module.exports = { plugins: ['react'], extends: ['eslint:recommended', 'plugin:react/recommended'], rules: { 'react/no-set-state': 'off', },} Glob 模式匹配eslint 运行后会默认在指定的目录下对所有的 .js 文件进行扫描，如果在配置文件中使用了 overrides 参数，则可以对需要进行检测的文件进行指定。如下面的配置文件则指定扫描 bin/*.js 和 lib/*.js 并排除了所有的测试文件。 1234567891011121314module.exports = { rules: { quotes: ['error', 'double'], }, overrides: [ { files: ['bin/*.js', 'lib/*.js'], excludedFiles: '*.test.js', rules: { quotes: ['error', 'single'], }, }, ],} 使用配置注释在文件的开头使用 eslint 开头的注释语句可以控制 eslint 对该文件的检测行为。在配置文件中如果配置了 noInlineConfig 属性为 true 的话，就不能使用文件内注释的方式进行配置了。下面摘抄几个配置注释的例子： 123456789101112131415161718console.log('1. 整个文件不检查 ===， 使用分号会报错')/* eslint eqeqeq: &quot;off&quot;, semi: [&quot;error&quot;, &quot;always&quot;] */console.log('2. 在 -- 之后给出一些说明')/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; -- Here's a description about why this configuration is necessary. */console.log('3. 在此文件中直接禁用/启用 eslint')/* eslint-disable *//* eslint-enable */console.log('4. 整个文件中禁用某些规则')/* eslint-disable no-alert, no-console */console.log('5. 下一行禁用某项规则')// eslint-disable-next-lineconsole.log('6. 这一行禁用规则')console.log('foo') // eslint-disable-line 常用配置项摘自另外一篇博客。 123456789101112131415161718192021222324252627282930313233module.exports = { 'no-var': 'error', // 要求或禁止 var 声明中的初始化 'init-declarations': 2, // 强制使用单引号 quotes: ['error', 'single'], // 要求或禁止使用分号而不是 ASI semi: ['error', 'never'], // 禁止不必要的分号 'no-extra-semi': 'error', // 强制使用一致的换行风格 'linebreak-style': ['error', 'unix'], // 空格2个 indent: ['error', 2, { SwitchCase: 1 }], // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 'array-bracket-spacing': [2, 'never'], // 在块级作用域外访问块内定义的变量是否报错提示 'block-scoped-var': 0, // if while function 后面的{必须与if在同一行，java风格。 'brace-style': [2, '1tbs', { allowSingleLine: true }], // 双峰驼命名格式 camelcase: 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， 'comma-dangle': [2, 'never'], // 控制逗号前后的空格 'comma-spacing': [2, { before: false, after: true }], // 控制逗号在行尾出现还是在行首出现 'comma-style': [2, 'last'], // 圈复杂度 complexity: [2, 9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always 'computed-property-spacing': [2, 'never'],} 命令行工具使用 eslint 的同名命令行工具可以对代码进行分析并将分析报告输出，其主要的使用方式是 eslint [options] [file|dir|glob]*，即最终的分析对象可以是文件、目录和 glob。可以通过选项对工具的行为进行自定义，下面总结一些比较重要的命令行工具选项。 --ext: 指定检测的文件拓展名，eslint 将在给定目录中对指定类型的文件进行扫描检测。如果不给出该选项，默认是 *.js； --fix: 修复检测出来的问题，但是有时候给了这个选项也修复不了相应的问题，这时候就得手动修改相应位置的代码了； --fix-dry-run: 修改检测出来的问题但是不进行保存； --cache: 传递该参数运行命令行工具的话会将检测结果进行缓存，下一次再执行缓存模式时将只针对有变化的文件进行扫描； --init: 初始化 eslint 的配置文件，传入这个参数会进入 eslint 的配置向导，从而生成符合用户期望的配置文件。配置向导如下所示：","link":"/2021/03/28/EslintTaste/"},{"title":"Github Actions的基本使用","text":"背景在毕业设计时捣鼓了一会应用的持续集成(Continuous Integration, CI)和持续部署(~ Deployment, CD)，发现确实可以为自己省下很多力气： 不用每次把代码通过 scp 或者 sftp 传到服务器上再 build 运行 也不用在本地交叉编译之后再传到服务器上 之前在公司实习时所有的分支合并都会涉及到 CI 和 CD，当时为了让代码编译通过费了很多心思。虽然自己push代码的时候比较费劲，但是确确实实可以给应用的部署和可用性提供保障。 最近在看阮一峰大神的技术博客时偶然看到了Github Actions的入门基本教程，发现 github 把 CI 脚本商品化、组件化放到 Marketplace 里供用户挑选和使用是一个非常不错的思路，让 github 的开源文化更加吸引人了。我把上面那篇博客看完之后发现其实和 Travis CI 差不多，或者说其实所有的 CI 系统都差不多。抱着接触新事物的热情，我还去看了 github actions 的官方文档，下面对我所了解到的一些信息进行一个汇总。 核心概念Github actions 中有下面几个重要的概念，直接上原文档： Workflow Jobs Steps Actions Runner 1. Workflow 工作流，工作流是由在 git 项目目录中的 .github/workflows/*.yml 文件定义的自动执行程序，可用于项目的构建、测试、打包、发布和部署。工作流又由一个或多个任务组成。 2. Jobs 任务，由一组步骤组成的单位。在工作流文件中可以定义任务如何运行：是并行执行还是顺序执行，以及以什么条件、什么顺序执行。在 Github-hosted 宿主机中，每一个任务都是在一个全新的虚拟环境中运行的。 3. Steps 每一个步骤都是一个单独的任务，可以执行 shell 命令或者是执行 action。一个任务里的所有步骤都是在相同的虚拟环境中执行的，使得不同的步骤可以通过文件系统共享信息。 4. Actions 翻译成动作有点太难听了，还是就叫 Action 吧。Action 是工作流中最小的可移植构建模块，你可以创建自己的 action，也可以使用社区里的 action，还可以对公开的 action 进行DIY。如果在工作流中使用，必须将 action 包含在步骤当中。 5. Runner 我把它叫做宿主机，宿主机分为两种：Github组装的和用户自组装的，他们存在着一些不同。宿主机等待用户的各种任务，一旦宿主机接受了任务，它会执行任务里的 actions，并把运行进度、日志和结果传给 github，用户可以在 actions 页面中查看这些信息。日志最多保存 30 天。 简单使用目标我的博客用的是 hexo 在 github pages 上构建的，博客所在位置是一个 repo，hexo 源码所在位置又是另一个 repo，我希望可以合并这两个 repo。或者退而求其次，我希望可以一次 commit 实现两个 repo 的 work done。这就要求我： 在源码 repo 处启用 actions 进行自动构建 将构建好的 repo 源码推送到 gh-pages repo 当中 在 Marketplace 中寻觅我找了四个公开的社区 action 想进行使用，发现他们存在着各式各样的问题，难怪最多的一个项目也只有 21 个 star。 自己写工作流文件deploy.yml123456789101112131415161718192021222324252627282930313233343536name: deployon: push: branches: [ master ]jobs: build: name: Build runs-on: macos-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v1 - run: npm install - run: npm install hexo -g - run: npm install hexo --save - run: hexo g - name: config git run: git config --global user.email &quot;$EMAIL&quot; &amp;&amp; git config --global user.name &quot;@NAME&quot; env: EMAIL: *** NAME: *** - name: bind github remote run: | cd ./public git init git remote add origin https://$PERSONAL_TOKEN@github.com/$USERNAME/$USERNAME.github.io.git env: USERNAME: fool-wang PERSONAL_TOKEN: $ - name: push public run: | cd ./public git add . git commit -m &quot;auto deploy&quot; git push -f origin master 该工作流每次在我向 master 分支 push 代码时会触发，其中任务只有一个 build，我给他设定的名字也是 Build。runs-on 指定宿主机，在这里因为我的电脑是 macos 系统，所以我希望宿主机可以和我的电脑操作系统相同，所以选择了 macos-latest。下面到了最最关键的步骤，一条一条地解释我做了什么（其实我也知道我的 push -f 很不优雅）： 用了官方的 actions/checkout 来获取 repo 文件内容 用了官方的 actions/setup-node 来获取 node.js 运行时环境，其实主要就是需要 npm 运行 npm install 命令，为项目安装依赖 运行 npm isntall hexo -g 命令，为虚拟环境全局安装 hexo 运行 npm install hexo --save 命令，这一步我非常不解，但是如果没有这一步之后的步骤会报错 运行 hexo g 命令，生成 public 静态页面文件 配置 git 信息，通过环境变量传入我的邮箱地址和姓名信息 通过我的 personal access token 将博客 repo 绑定到生成的 public 文件夹远端 将 public 内的文件强制 push 到博客 repo 中，希望实现文件替换，也就是实现了部署过程 问题，大问题我发现宿主机内执行 hexo g 命令生成的文件与在本地电脑上生成的文件不一致，下面放几张图片： 上图是本地执行命令的生成的文件，下图是宿主机执行命令生成的文件，差别那么大就很离谱。 更离谱的是，博客 repo 上新部署的 index.html 文件内容是空。 结语Github actions 的基本使用倒是已经掌握了，但是没办法实现博客源码自动构建和自动部署是有点困扰我，其中最神奇的问题就是 hexo g 生成的文件不同。不知道这个是我的打开方式错误，还是 github actions 环境有问题，还是 hexo 有问题。（最后一般都是我有问题） Github actions 使用体验不错： 在私有 repo 中也能够免费使用，真心觉得微软爸爸好 任务执行流程、日志和结果呈现十分友好 marketplace 的思路新奇，有许许多多开发者贡献代码，社区活跃度高，今后一定会变得更易用 构建失败后会有邮件提醒 之后有时间还会继续深入了解 actions，争取把今天遇到的问题给解决掉了。 后续hexo g 命令生成的文件与在本地不同是因为…我漏掉了 git clone 模板库的步骤。第二天早上在 hexo g 之前补上了下载模板库的命令之后就正常工作了。熬夜害人熬夜害人。 参考文献 GitHub Actions 入门教程 GitHub Action 官方文档","link":"/2020/05/09/HowToUseGithubActions/"},{"title":"青岛（一）","text":"说在前面最近两个月遇到了不少的烦心事，让我颓废了好一阵子：懒得写博客，懒得跟人说话。很久没有到过海边，都要忘了在海边吹风是什么感觉了，趁着这次五一假期，和两个朋友一起去青岛玩了玩。虽然总共只待了 3 天 4 晚，但是还是有两点收获： 青岛是一个不错的城市； 不要在黄金周出游； 首先，临海的青岛让我这个南方人感受到了久违的湿润，终于不用担心因为干燥导致的皮肤瘙痒和手指倒刺，让我能够把身体乳和护手霜安心地放在行李箱里。青岛风景很美，海鲜很丰富，从视觉和味觉上都给了我满足感。 可能也是因为它的好，让大家在黄金周里都想去看看。我们 4 月 29 号晚上到时还很冷清，街道上车马稀疏，但到了 5 月 1 号立马到处都人挤人起来——我们计划中的不少的去处都是被人海给劝退的，比如信号山公园和小麦岛等等。我很讨厌人扎堆的地方，不管再好的去处，一旦人群密集起来我就会变得很焦躁。今年五一期间大家因为疫情缓和而报复性出游，让我感受到了人们的热情。所以趁着还在学校读书，假期安排比较自由，以后还是尽可能在非公共节假日出游吧。 栈桥、啤酒和皮皮虾栈桥4 月 30 号我们开始了第一天的游玩，风特别大，尤其是在海边。虽然 14 度的气温不比北京低多少，但是直观感受起来体感温度可能只有七八度，大概率是 60%的湿度导致的吧。 我们住在青岛火车站旁边的一栋高楼里，距离海边特别近，随便吃了点早餐就往海边走了。路上遇到了很多位推销旅游项目（游船、快艇、潜水等）的大叔大妈，“4 月 30 号人少半价，明天再来就不划算了”。我对这种主动推销的旅游项目不是特别感兴趣，我只想自己沿着海岸走走看看、踩踩沙滩，不想因为“今天便宜”就去坐船或者潜水。 但是旅游嘛，总是要花些冤枉钱的。他们俩很想坐游船和潜水捕捞，一起来的还是不要扫他们兴比较好，我就也买了游船的票。潜水是真的不敢去，大风低温的天气下水和冬泳没什么区别了。游览栈桥的计划就暂停了，我们坐上一辆面包车被一起送到了不远的潜水俱乐部。在他俩潜水的时间里，我就在八大峡广场周围走了走，吹吹海风，拍拍照片。下面是几张我比较喜欢的照片。 因为是刚接触摄影，对用光、构图和相机参数都没有特别深入的了解，基本都是用半自动模式靠感觉瞎拍的。但是把看到的东西好好的拍下来的仪式感也非常契合我对“记录”本身的喜爱。 他们俩从水里出来之后很长一段时间都在瑟瑟发抖，可以看出确实很冷，同时我也庆幸自己没跟着去。他们还从海底捞出来一些贝壳和海星，观感不太好就不在这里放照片了，而且到晚上它们都发臭了…收拾好后我们才开始往栈桥方向走。这时候是中午 12 点多，但是温度反而比上午 10 点更低了，沿着海边从俱乐部走到栈桥的过程中经历了急风骤雨和雨过天晴，现在想起来这也算是一种奇妙的体验了。 栈桥景区的结构挺漂亮的，拱桥长廊和末端的回澜阁一起组成了“海上如意”的形状。有很多人喂海鸥，有人把吃食放手掌上，海鸥都不过来；有人直接把吃食往空中抛，靠近的海鸥们会竞相争食。还挺有意思的。 啤酒博物馆每去到一个地方我就想去当地的博物馆。提起青岛肯定就会想起青岛啤酒，在网上看了攻略的我们在这样寒冷的天气里还是决定离开栈桥前往啤酒博物馆。我们叫了辆滴滴，但是司机偏偏不走系统推荐的稍微远一点但是不堵的路线，而是选择了走大学路。虽然行程时间比预计的多了一倍，我们却能够在车上仔细品味网红街的美，嗯我就是在吐槽这个出租车司机。 我觉得青岛啤酒博物馆建设和运营得非常好。它分成了 A/B 馆，A 馆是不收费的，视角宏大地讲述了青岛啤酒的历史和成就，B 馆里则细致地介绍了啤酒的酿造工艺，赠饮啤酒原浆，出售文创纪念品，甚至还展示了青岛啤酒的生产车间。中途和终途酒馆都可以领取啤酒，对于喜欢喝啤酒的人来说这里是个不错的去处。 晚餐从啤酒博物馆出来我们就到了台东步行街，这里整条街都是海鲜大排档。我们几个人在“晚饭吃什么”这个问题上出现了分歧，有人想回去吃，有人想就近吃，有人想在回去路上边走边看，一度有些不愉快。这时也有店家从路对面走过来招徕，拉踩其他家店，看到这个状况我们都不想在这边吃任何一家店了。 回去路上看到一家店叫做“沂水人家”，大众点评上查了一下发现评价还不错，我们就选定了这家店。不过，不知道是不小心还是有意为之，他家菜单里写的烤多宝鱼是 78 元/只，但是我们点了一只之后店家跟我们说是 78 元/斤，虽然味道还可以，但是感觉上还是比较奇怪的。除此之外，我们还点了酱猪蹄、清炒茼蒿、辣炒蛤蜊和椒盐皮皮虾，味道都还不错。尤其是椒盐皮皮虾，椒盐永远的神！火候控制得很好，香酥的、椒盐味的壳变得很有风味的同时，虾肉保持了鲜嫩的状态。在这顿饭里皮皮虾毫无疑问是 MVP。 崂山、天主教堂、五四广场和海我发现开始写之后就变得很啰嗦，总是想把看到的听到的都写下来，记录一天的行程就花了很长的时间。索性拆成两篇来写吧！","link":"/2021/05/05/JourneyToTsingTao-1/"},{"title":"青岛（二）","text":"从青岛回来之后马上就是学生节和一系列的课程、任务和作业，根本没时间和心情来写这篇博客，所以青岛（二）这一篇拖了很久…但是过了一个多月的时间很难再拾起当时的心情了，从拍下来的照片里才能记起来去过哪里有哪些好玩的地方，可以说是看图说话。反正也没人看，我直接这样随便写写就当给自己一个交代好了，不喜欢做半途而废的事情。正义虽然会迟到，但永远不会缺席。 这一篇我们主要是去了崂山、信号山公园、天主教堂、五四广场转了转。 崂山仰口海边不知道我们怎么想的，不远千里的到青岛去爬山受累，可能这就是正经的游客吧？在前往青岛的高铁上我们才开始做攻略，在马蜂窝上找了几个青岛游的攻略，都说崂山是必须要去的地方，所以我们把崂山列在我们第二天的行程当中。好巧不巧我们选了仰口区，从市区里过去要做两个小时的地铁大巴，实在是太久了。在第一天的 2 万步之后我坐完这两小时的行程时已经有一点蔫了，到了景区下车的时候热浪扑面，虽然前一天很冷，但是这天中午阳光非常充足，把前一天的凉意一扫而空。仰口景区的结构是这样的，景点的起点是在山脚，离海非常近的位置，我们先在海边玩了玩。买了风筝想在海边放，但是奈何海风太猛且方向不确定，很难让风筝飞得高远且持久。朋友都弄的鞋里都是沙子了，但就是不能让风筝飞得让自己满意——只能怪风况不佳咯。 此时已经是12点多，我们还没有吃午饭，于是灰溜溜的到周边去找地方吃饭。景点里的餐厅又贵又难吃这是我们的共识，于是我们找了一家超市，各吃了一桶方便面（实惨）并买了一些饮料和物资背在包里开始上山了。 山和海天公不作美，我们刚检票入园就下起了雨，我们撑伞走了一段时间雨才完全停。不过这也算好，这也使得景区没有特别热。仰口景区有些道观和寺庙，这些我不是特别感兴趣就不提了。随着爬的高度越来越高，视野逐渐开阔时，我的心情还是很激动的，毕竟很少看到这样的山海景，波澜壮阔、云海翻涌的场景不由的在脑海里开始放映。我们爬到一定高度后在一个亭子里拍了下面第一张照片，山、海、天交相辉映…很难形容我当时的想法。 上面的照片是随着高度的不断提升排列的，每上一定的高度都会有不同的景象，每个地方我都拍了一些，其中最后一张是在山顶拍的。 山顶风特别大。有一个景点叫做“天苑”，一块巨石被另外的石块三个点支撑着却稳稳地立了起来，很有意思。山顶的驻足点由山体本身和一些悬空的木质围栏、栈道组成，些微恐高的我站在木质栈道上有点胆战心惊的，生怕被风给吹垮了或者是被这么多人的重量给压垮。站在上面看着山麓茂密的树林和蔚蓝的海水及其上随风而动的云的阴影，体会到了在北京爬山体会不到的感觉。（毕竟在北京爬山都看不到海) 觅天洞明明可以走平坦的路，我们偏偏选了特别难走的一条。去往山顶可以走常规的楼梯和一个叫做觅天洞的地方，我们也没多想就选择走觅天洞这条路了。进“洞”之前我们看到了一些警示标语——“患心脏病或者心脑血管疾病人士请折返”，我们还纳闷这不就是一个景点至于这样警告游客吗？我们偏不信就进去了。 然而结果就是它真的和它的名字一样是一个洞，内部非常的潮湿、狭窄、黑暗。我们在其中全程蹲下来扶着墙走，遇到需要爬楼梯的地方我们也几乎是贴墙爬行，用“贴地爬行”一点也不夸张，非常狼狈。爬了二十多米的高度之后终于到了开阔一点的地方，能够看到阳光了。我至今能够想起当时大家一起“苟”的样子，除了我们几个小伙子外还有一些爷爷奶奶辈的人，我非常担心这些人群的安全。非常不推荐以后有人走这个地方：我觉得这个地方作为一个景点是不合格的，标语警示强度不足，谁能知道里面是这样一个样子呢？ 没有图，就是一个约莫一人宽的洞。非要说它给我留下什么好的印象的话，那就是或许可以当作体验一下桃花源记渔人见到“山有小口，仿佛若有光，便舍船，从口入”的经历吧。 下山下山感觉比上山还累，因为上山的时候腿脚已经很疲惫了，下山走楼梯又要不断地给膝盖压力，到山脚的时候感觉膝盖有点废了。又是两个小时的大巴地铁回到住处之后天已经黑了，随便吃了一点东西我们就休息了。 其实还按照网上的攻略指示去了一趟“劈柴院”，就是一条哪里都有的古风商业街。真的是 哪 里 都 有。一点意思都没有。 天主教堂、五四广场其实没有什么新颖的和印象深刻的东西值得一提。就放几张照片吧，从上到下依次是天主教堂里的窗户、鱼山路某咖啡馆里的大猫、奥帆中心的帆船和海。 在六月的夏天里写五月的海一篇游记拖了一个月才凭借着回忆来写属实有点不可思议，但是这一个月里有很多的课程任务、课题组和辅导员的工作需要处理。直到自己最近把课程的事情都处理完，才能闲下来写这篇博客。 我发现当我有其他非常要紧且糟心的事情需要解决的时候，我总是很难静下心来做写博客、拍照片、写闲代码这样的事情。可能我的“多线程”能力还有待提高吧，或许是我的抗压能力不太行？听过很多关于现代人时间管理方面的说法，时间是海绵里的水，挤一挤总是会有的，觉得现在看大家在朋友圈里玩得很欢乐，其实玩乐之后还是有很多事情是亟待完成的。 绝大多数的人无非都是带着脚镣跳舞，但是我带着脚镣的时候我想的不是如何跳舞，而是如何把脚镣解开。这或许是不太现实、不太成熟的想法。生活中谁能够完全把手铐脚镣解开呢？解开一个脚镣之后又会发现自己被新的、更大的脚镣锁住，如何戴着脚镣跳舞，如何把脚镣舞跳好可能是未来的我给自己的重要课题。 北京的六月特别热，让我又想起了青岛五月的海风了。","link":"/2021/06/13/JourneyToTsingTao-2/"},{"title":"对Python,Golang和C++三种语言GC机制的简单调查","text":"调查背景在公司一项任务是需要调用Python的SDK爬取相关的数据信息，数据的量在10亿这个量级，故不能够一下子得到结果。这个程序运行十来天的可能性比较大，但是问题来了，程序跑过一阵子（1小时）之后爬取效率明显降低。重启之后效率恢复，这就让人有点不爽了，本来数据量就多，用初速度爬取也需要十来天，这样一减速得爬到什么时候呢？通过使用top工具，观察到爬虫脚本在运行过程中占用的内存从800MB上升到了1.4GB，速度也随内存占用量的上升而减慢。（图片来自MacOS的top，与程序的运行环境中的top不太一样）我猜可能是内存泄漏了，各种查资料之后用python的gc和objgraph进行程序内存使用情况分析。虽然针对于爬虫程序的分析无果，但是对GC机制有了一点兴趣，于是稍微了解了一下。 下文的 GC 既指 Garbage Collection， 也指 Garbage Collector。 接触Python一年多，Golang九个月，C++是大一时OOP课上教授的语言。其实都只是了解了皮毛，仅仅停留在“会用”这个层面。 三种语言的GC机制Python1. 引用计数引用计数是一个很简单的实现方式，顾名思义： 当一个对象被引用时，该对象的引用次数+1； 当引用这个对象的另一个对象被GC回收时，该对象的引用次数-1；当GC监测到某对象的引用次数为0时则将该对象回收。 但是这个方案无法解决循环引用。 2. 分代回收根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活时间长的为老年代。这样就可以根据每块内存的特点采用适当的收集算法。在新生代对象中进行高频回收，在这次回收中没有被清理的对象移动到老年代对象中，老年代对象执行低频回收。 上面是分代回收的定义，但是python没有简单的把对象分为新和老两个代际，而是分为了三代。每一代的对象达到了一定的数量（Threshold）之后GC会执行相应代际的对象回收，这个阈值是可以通过gc包进行设置的（gc.set_threshold），我调用gc.get_threshold()得到的结果是(700, 10, 10)。不像引用计数，分代回收是可以进行控制的，甚至是关闭。如果觉得GC太频繁造成了性能瓶颈，那么可以提高阈值，降低GC频率。 Golang1. STWGolang的早期版本被无数人所诟病的问题之一就是它的GC，它用的是标记清除方法，也叫Stop The World(STW)。该方法从根变量开始迭代，遍历所有被引用的对象，能够访问到的都标记上“被引用”；之后对没有标记过的对象进行清理，即回收不可达的对象。但是每次执行该算法都会让正常执行的内存负荷型程序出现明显的卡顿，这也是为什么该方法又被叫做STW的原因。 2. 三色标记法该方法是对标记清除算法的改进，原理如下： 起初所有对象都是白色的； 从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列； 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色； 重复步骤3，直到灰色对象的队列为空。这时仍为白色的对象被当作垃圾回收。 下面是演示图： C++ In early programming languages, developers were responsible for all memory management in their programs. This meant before creating a list or an object, you first needed to allocate the memory for your variable. After you were done with your variable, you then needed to deallocate it to “free” that memory for other users.[2] C++就是early programming language，它较Python和Golang而言更偏底层和接近系统，将内存管理的工作交给程序员来完成。简而言之，就是没有GC（当然后来的C++11、14的新特性在此不提及）我之前写的某程序就因为想要释放整个数组的空间但是只写了delete xxx而不是delete[] xxx，仅释放了数组首位元素的空间，导致了剩余所有元素内存资源的浪费。为了减轻程序员手动管理内存的痛苦，C++11推出的智能指针算是一个宝贝。 参考资料 GO GC 垃圾回收机制 Python Garbage Collection: What It Is and How It Works 如何理解智能指针？ - 知乎","link":"/2019/06/12/GarbageCollectionSurvey/"},{"title":"小程序框架：WePY、uni-app 和 Taro","text":"在上一篇博客《聊聊微信小程序及其框架》里面立了个调研微信小程序开发框架的 flag ，这篇博客就来填这个坑——我迫不及待地想要掌握一个能够“舒适编写”小程序代码的框架。 我之前提到我最想先要了解的是 WePY 和 uni-app 这两个小程序框架，WePY 是微信官方出品的小程序框架，uni-app 是使用 Vue 开发小程序的最火的小程序框架，但是这两个框架都让我特别失望。 令人失望的 WePY 和 uni-appWePY其实最期待的应该是微信的亲儿子 WePY 吧，毕竟是官方出品，质量应该会有所保障，但是看了文档并自己安装运行之后发现还是不对胃口。原因主要有以下几个方面： 语法以 Vue 为基础但是又在 Vue 的基础上进行了一点魔改，让人产生一定程度的混乱。如果要使用类 Vue 的语法来写小程序，为什么不直接用 Vue 来写呢？ 插件支持不到位，例如 vscode 中的插件 Wepy 就是完全用 Vetur 魔改出来的，在 .wpy 文件中的提示和各项支持并不到位，会提示有各种 warning 和 error； 使用 @wepy/cli 工具创建标准模板项目之后发现并不能正常编译。 第一印象很重要，如果这个框架第一时间没有让我感觉到便利，甚至是让我觉得很麻烦，那我是绝对不会再继续在继续研究它的。到这里，WePY 的尝试就结束了。 uni-appuni-app 是由 DCloud 开发的一个小程序框架，致力于让开发者用 Vue 写一套代码编译到 10 个平台都能运行。虽然一开始对于这种为系统引入过多复杂性的框架有些抵触，但是最简单的 WePY 凉了，所以也愿意相信 uni-app 说的: 即使不跨端，uni-app 也是更好的小程序开发框架、更好的 App 跨平台框架、更方便的 H5 开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。 知乎上也有相关的帖子，说 uni-app 比较香，写起来很省心。抱着尝试的心态看了一下 uni-app 的官方文档、用 vue-cli 安装了 DCloud 官方的项目模板尝试编译运行、下载了 HBuilderX 尝试编译运行。运行是能运行，但是效果马马虎虎，体验有点糟糕，印象大打折扣。主要的问题有以下几点： 官网文档有些混乱，非常非常非常着重的说明如何进行跨端的适配、条件编译有何注意事项等等，对于只想简单在单一平台编译运行小程序的开发者来说不够简洁； 命令行工具的表现和 HBuilderX 的不一致，大部分情况下命令行下都编译运行不了，或者是当我想引入一些如 Vant 的组件库的时候小程序就编译错误； 上一条提到的部分问题如果使用 DCloud 的官方 IDE HBuilderX 的话就可以用“导入插件”的方式解决一部分。但是体验非常非常差，简直就是道德绑架——要编译就要用我的 HBuilderX。什么？你没安装啊，那打扰了； 尝试使用官方推出的插件将使用原生微信小程序语法编写的代码转换成 vue 风格的 uni-app 代码，但是转换出来之后一团糟，根本没办法运行。 uni-app 最大的问题在于它太复杂、太希望构建自己的生态、太希望牢牢抓住开发者了。复杂的东西往往都很脆弱，经不起折腾，稍微碰一下就错误百出。它几乎是强制开发者使用他们的 HBuilderX 来进行小程序开发，这一点我无法接受，你不让我自由选择开发工具，我就可以不用你。但是这些问题也情有可原，毕竟它是 DCloud 的主要业务之一，需要给公司带来一定比例的收益。 Taro 宇宙最强的泰罗奥特曼Taro 文档阅读我一直觉得很多开发者都非常可爱，从起名上就可见一斑，比如 Taro 这个小程序跨端框架、分布式应用程序协调服务 ZooKeeper 和分布式系统基础框架 Hadoop 等。Taro 是京东的凹凸实验室推出的小程序跨端框架，和 uni-app 一样支持写一套代码编译到不同的地方。目前已经进入了 3.x 阶段，除了可以用 React/Nerv 进行开发，还支持了 Vue/Vue3。我马上看了看 Taro 的官方文档，比 uni-app 好太多了：快速开始、基础教程、进阶指南、迁移指南层层递进；官方组件库和 API 列表罗列清楚，对它们在 React 和 Vue 中的使用方法说明得很清楚；还提供了专门的“教程”模块，对于刚上手的开发者十分友好；更重要的是，它提供了一套原生的 UI 组件库 taro-ui ，甚至还照顾了 Vue 的版本推出了 taro-ui-vue。依靠这些了解，我就觉得以后就是它了，要是再有新的小程序项目，我应该会首选使用 Taro 进行开发。 尝试初始项目于是，我赶紧创建了 taro-taste 文件夹。 本来打算随便写一个 demo 小程序，又不想再单独写一套后端代码（再简单也懒得弄了），就用之前申请的一个小程序用来作为云开发的基础。用 taro 自带的 cli 工具初始化了一个微信小程序的云开发模板。用微信开发者工具打开之后，一切表现都很正常，没有什么复杂的事情，没有类似 uni-app 一样的满屏 error，云函数也能够正常调用。但是用 Vue 开发小程序有一些其他的点是需要重新适应的，例如： template 部分的基础元素只能用 view 而不能用 div； 事件名称或许不一样，如点击事件需要用 tap 而不用 click 等； 安装 taro 官方的 package 最好改用淘宝的源或者直接使用 cnpm ，不然就会出现安装失败的问题。 不过整体而言已经很满意了，对 Vue 的支持也比较全面，之后应该会真正用它来进行开发吧。 不如了解一下新东西但是有一点比较奇怪的是，在 Vue 项目模板的首页文件中，根节点 view 元素有个 className=&quot;index&quot; 的属性，这是 React 类名的写法。想到 Taro 在 3.x 版本以前只支持 React/Nerv 的情况，出现 className 这个属性应该是 3.x 版本目前还没有把对 Vue 的支持做得很完善吧。 恰好我最近在做其他项目开发的时候感觉 Vue 在代码复用、数据更新和访问方面的一些体验不是特别友好，而且组件文件规模很难控制（这应该是我的编码水平问题…），不如去学习尝试一下 React 吧。听说 Hooks 配合函数组件用起来很舒服，而且 React 完全是在写 javascript/typescript，开发起来应该会比一个文件里写 template/script/style 来回切会容易把控一点吧。 当然，它们归根到底只是开发框架而已，前端项目开发万变不离其宗，但是了解一个很酷的新东西本身就可以给我很大的动力，对吧？","link":"/2021/03/14/MiniprogramFrameworks/"},{"title":"Nginx 基础","text":"背景Nginx 读作 engine x，是一个高性能的 HTTP 和反向代理服务器，还能用作邮件代理服务器或是通用的 TCP/UDP 代理服务器。有过后端程序部署经历的同学应该会有所了解，用 Nginx 能够很方便地完成反向代理、服务静态文件、实现负载均衡、接入HTTPS协议等任务。 根据官方文档里面写到的，除了提供静态文件服务、反向代理和负载均衡等功能之外，还提供以下包括单不限于若干个方面的支持： FastCGI, uwsgi 之类服务器和反向代理服务器的缓存支持； 以域名/IP为基础的虚拟服务器、Keep-alive 和流水线链接的支持； 访问日志、错误日志的输出和格式化，带缓存的日志写机制； 3xx-5xx 错误码重定向，根据正则表达式重写URI (Rewrite)； 基于客户端地址的访问控制和函数调用； HTTP referer 的验证、支持除了 GET 外的几种 HTTP 方法： PUT/DELETE/COPY/MOVE/MKCOL； FLV/MP4 的流播放、响应限流、限制单点的并发连接数和请求数； 等等…（上面只列了我读得懂的） Nginx 的功能实在太多了，在这里全部列出来不太可能。一直以来我对 Nginx 都停留在“配置是什么，work 就行”的态度。因为这周程序部署时遇到的一点问题，上网搜了好多帖子、博客寻求解决方法那种捉襟见肘、有病乱投医的样子让我觉得很狼狈。借此为契机，决定周末看一下 Nginx 的官方文档。nginx 旧版的官网文档组织混乱，建议移步 Nginx Plus (Nginx 的商业版)官网。Nginx 和 Nginx Plus 的对比放在这里。 基本功能概况Name/IP-based Virtual serversNginx 接收到请求之后会首先决定让哪个 server 来接受这个请求。在 nginx 的配置文件中使用 server 这个指令可以定义“服务器”区域，当然最后到底是谁处理这个请求也是看 server 是如何定义的。下面是示例代码块： demo.conf1234567891011121314151617server { listen 80; server_name example.org www.example.org; ...}server { listen 80; server_name example.net www.example.net; ...}server { listen 80; server_name example.com www.example.com; ...} 这个配置文件定义了 3 个服务器，都监听了 *:80 端口。Nginx 接收到请求之后会转发给 server_name 字段与请求头中的 Host 字段相同的 server 进行处理。如果没有完全对应的 Server 那么请求会被转发到默认服务器进行处理。default_server 是 listen 指令的可选参数，如果在端口号后加上 default_server 表示这个服务器是默认服务器。如果没有任何 server 有 default_server，那配置文件中定义的第一个 server 就是默认的服务器。 对 listen 中的 IP 地址进行配置也是可行的。下面再看一个配置文件： demo2.conf1234567891011121314151617server { listen 192.168.1.1:80; server_name example.org www.example.org; ...}server { listen 192.168.1.1:80; server_name example.net www.example.net; ...}server { listen 192.168.1.2:80; server_name example.com www.example.com; ...} 这个配置文件下，Nginx 会先判断请求的 IP，再判断 server_name 字段。 Locations路径配置规则在 server 区域之中，可以定义若干个 location 区域。location 指令可以根据请求的 URI 将请求分发到不同的代理或者不同的静态文件目录中，后面提到的所有 location 配置都在 server 区域之中。 location prefix 匹配符合 prefix 前缀的 URI，如果一个请求的 URI 匹配了很多 location 的 prefix 那么请求会被分发到 prefix 定义最长的 location 块中。另外，location 指令还可以有标识符配置： location = path 表示 URI 需要准确的等于 path 才会落到这个 location 区域进行处理； location ~ regex 表示 URI 匹配相应的正则表达式。如果是 ~* 的话，是忽略大小写的； location ^~ prefix 表示这个 prefix 匹配的话，不考虑相应的正则表达式； 匹配优先级要找到最好的 location 块来匹配一个 URI，Nginx 会先匹配所有的 prefix，然后再匹配所有的正则表达式。但是 Nginx 会给正则表达式更高的优先级，除非有 ^~ 标识符。准确的匹配流程如下： 将 URI 与所有的 prefix 进行比对； 如果 = 标识符的 location 命中了，直接使用该 location 进行处理，匹配过程终止； 如果有 ^~ 标识符标识某个 prefix，则后续不用正则表达式检测这个 prefix 命中的 URI； 保存最长的匹配的 prefix； 将 URI 与所有的正则表达式进行比对； 如果 URI 匹配到某个正则表达式，立即停止比对，用这个正则表达式对应的 location 进行处理； 如果没有正则表达式匹配，用第 4 步保存的最长的 prefix 来处理。 那么根据这个流程，在配置 / 对应的处理方式时，使用 = 标识符能够提高 Nginx 的响应速度。 root, index, proxy_passroot, index, proxy_pass 是几个在 location 区域内常用的指令，这里专门查一下它们的用法。 root path 用文件系统路径来表示，表示在这个 location 中从哪个目录找静态文件来服务； index file ... 定义首页文件，按照给定顺序注意匹配，最后一个文件名可以是绝对路径； proxy_pass url 将请求转发到某个代理服务器上。 变量和改写变量在 Nginx 的配置文件中可以使用以 $ 开头的变量，和 linux 的 shell 变量相似。Nginx 预定义了很多变量如 $remote_addr 表示客户端的 IP 地址，$uri 表示目前 URI 的值。用户也可以使用 set 和 map 这两个指令在配置文件中自定义变量。 Nginx 内置的变量列表在这里可以查看：core HTTP 改写return 使用 return code [url/&quot;string&quot;] 可以给请求返回相应的状态码，或者直接以 30x 的状态码跳转到后续的 url，以 200 的状态码返回一个 string。 demoReturn.conf123456789location /wrong/url { return 404;}location /permanently/moved/url { return 301 http://www.example.com/moved/here;}location /text/url { return 200 &quot;hello world&quot;;} rewrite 使用 rewrite regex target cmd 可以将 regex 匹配的路径改写到 target，cmd 这个参数有 break 和 last 这两个最常用的。它们俩的区别有两点： last 会终止在当前 server 或者 location 区域当中的 rewrite 执行，但是重写到 target 之后落在新的 location 中的 rewrite（如果有的话）还是会继续执行； break 终止当前背景下的 rewrite 执行之外，新的 location 中的 rewrite 也不会执行。 rewrite 的例子可以看下面的配置： demoRewrite.conf123456789location /users/ { rewrite ^/users/(.*)$ /show?user=$1 break;}server { rewrite ^(/download/.*)/media/(\\w+)\\.?.*$ $1/mp3/$2.mp3 last; rewrite ^(/download/.*)/audio/(\\w+)\\.?.*$ $1/mp3/$2.ra last; return 403; # 可以组合使用} 总结这次走马观花看了一篇最基础的教程有了较多的新认识，服务静态文件、反向代理、压缩和解压缩、内容缓存等等内容在 Nginx Plus 的文档中都有比较系统的讲解，之后有需要或者有时间的时候再看看吧。","link":"/2021/08/15/NginxBasics-1/"},{"title":"论文阅读: Role-Based Access Control Models, 1996","text":"摘要论文描述的方法简称RBAC，基于角色的访问控制，是目前非常主流的访问控制方法。用户（User）、角色（Role）和权限（Permission）是论文中最主要的三个概念。角色和用户组这个概念很像，但是用户组仅仅只是一个用户集合，而角色则联系着用户和权限。说到底都是为了让用户获取权限来执行相应的操作，不管是加入角色还是用户组，都只是一个中间态。 RBAC0是基础模型，是任何系统实现RBAC的最低要求。RBAC1和RBAC2都包含了RBAC0，但是分别加入了不同的特性。RBAC1加入了角色层级特性，即角色A可以通过继承角色B获取角色B拥有的权限。RBAC2加入了约束特性，控制用户对RBAC中不同资源、组件的权限。而RBAC3包括了角色层级和约束。示意图如下所示，其中基础模型RBAC0是实线部分。 文章并没有给出模型具体的实现方案，这些模型主要用作产品开发的指导准则或设计原型。 RBAC模型族RBAC0基础模型主要由用户U，角色R和权限P三个实体集组成，图表中也表示出了会话S。用户代表使用系统的每一个“人”；角色代表负责一系列职责的人群，用职业或者岗位来理解；会话是将从用户到多个角色的映射。权限需要详细说明。 权限是访问一个或多个数据对象或其他资源的许可证，权限通常是正向的，即拥有权限后可以访问对应的对象。但是有的模型把权限设计成为负向的，即获得这个权限后将无法访问对象。RBAC模型中将负向权限建模成为“约束”，后文会提及。权限的含义完全取决于系统的类别和系统的实现细节。操作系统中区分了文件、目录、设备和端口等对象的读、写和执行操作；数据库对关系、元组、属性和视图等对象的查询、更新、删除和插入操作进行了区分。 图1还展示了用户分配UA和权限分配PA关系，它们都是多对多关系。RBAC的关键就蕴藏在这两个关系当中。RBAC0中各组成部分为： U, R, P, S，分别代表用户、角色、权限和会话 PA，权限分配，权限到角色的多对多关系 UA，用户分配，用户到角色的多对多关系 user， 从一个会话映射到一个用户的函数 roles，从一个会话映射到一个角色集的函数 RBAC1RBAC1在0的基础上加入了角色层级，这个特性在现代组织管理当中显得很自然。层级高的角色继承层级低的角色的权限，如Team Leader可以访问所有项目的细节而Project Programmer只能访问所属项目。 从离散数学的角度来说，角色间的层级是偏序关系，即满足了自反性、传递性和反对称性的关系。 私有权限或私有角色通常用于控制角色继承时的权限作用域，如对进展中的为完成工作访问权限如果从低级角色直接继承到高级角色似乎不是特别合适。如Team Leader不应总是收到每一位Programmer的CI Build失败通知。 RBAC2RBAC2在0的基础上加入了约束特性，这个特性有时被称作RBAC的灵魂。约束是是一个强力的机制，可以用来打造更高水准的组织管理架构。下面是文章介绍到的一些常见约束： 互斥约束，互斥顾名思义就是用户只能获得其中一个角色身份，或者同样的权限只能赋予其中一个角色； 基数约束，一个角色最多只能拥有一定数量的成员； 先需角色约束，给用户分配角色A之前需要该用户拥有角色B的身份； 角色层级约束，没错就是RBAC1中的角色层级，它也可以被看作是一类约束。 RBAC3RBAC3就是把1和2组合起来，既有角色层级又有约束条件。 基于RBAC的管理模型上面提到RBAC模型当中所有组成部分都是由一个安全管理员直接负责，这样的情况只有在极小的系统中才有可能存在。任何稍大一些的系统都有多个安全管理员。由于RBAC的主要好处就是实现了权限的管理，那么如何让RBAC来管理RBAC本身呢？论文提出的管理模型在图4中展示，其上半部分就是之前的图1(b)部分，其下半部分是上半部的镜像，其中包含了管理角色AR和管理权限AP。权限只能授予给角色，管理权限只能授予给管理角色。 RBAC模型中的管理权限可以视作修改用户分配UA，权限分配PA和用户层级RH关系的能力。这样就可以实现用RBAC模型管理自己了。 参考文献[1] Sandhu R S, Coyne E J, Feinstein H L, et al. Role-based access control models[J]. Computer, 1996, 29(2): 38-47.","link":"/2020/05/18/ReadRBAC/"},{"title":"打包发布 React 组件库","text":"起因「代码写了不测等于白写」我总是跟身边的朋友这样调侃。然而我们写前端项目时很难在代码层面进行测试，大部分函数都是基于事件响应，接收用户输入的参数，并对页面组件或数据产生一定副作用，Mock 起来很麻烦。所以前端项目的测试往往都是端到端测试，即模拟用户在页面上进行操作，测试路径越离奇越好，因为无法提前预知用户会如何使用，所以最好在测试时可劲儿造。 曾经还会想着用 Cypress 等自动化工具进行端到端测试，例如用代码定义【打开某页面–&gt;拖拽滑动条至页面下方–&gt;点击输入框使之获取焦点–&gt;输入“Hello world”–&gt;按下回车–&gt;等待页面响应–&gt;观察响应是否符合预期】这个过程，但只要遇到元素稍多的页面，编写测试用例的过程就会变得机械呆板。 如果组件足够小，内容够聚焦，那么测一下也不是不可以。因为想在不同的项目中复用同一套富文本编辑组件(体积比较大，且包含机器构建的JS)，我把它单独提出来作为 NPM 包发布以便各个项目安装使用。这当中编码和测试都遇到了一些问题。 打包经过目标既然要在不同项目之间共用，那该组件肯定至少已经应用到一个项目中。所以最终目标就是把项目中原先引入的组件完全替换成为 NPM 包版本的组件后，所有富文本编辑预览功能都照常。 原先组件结构CKEditorFormFields.tsx12345678910111213141516import './some-styles.css';import React from 'react';import { CKEditor } from &quot;@ckeditor/ckeditor5-react&quot;;import CustomBuildEditor from '@ckeditor/ckeditor5-custom-build'export const CKEditorInput: React.FC&lt;ControllableFormFieldProps&gt; = () =&gt; { /* * ... */ }export const CKEditorRenderer: React.FC&lt;ControllableFormFieldProps&gt; = () =&gt; { /* * ... */ } 原先的组件定义基本上如上面片段所示，其中 CustomBuildEditor 利用了 CKEditor5 的自定义构建，算是按项目需要选取必要功能构建出来的编辑器母版，它本身的使用方法很 HTML，不太适合直接用在 React 项目里，需要用 @ckeditor/ckeditor5-react 进行包装。 而这个 CustomBuildEditor 是自定义构建工具编译好之后打包好后（后续用 ckeditor-dist 称呼）下载到本地的，如果不用 NPM 包的话需要在几个项目间复制粘贴。或许因为我们项目用的是 TS，无法直接从本地目录下直接引入，所以我们用 package.json 依赖的文件链接定义了一个叫做 @ckeditor/ckeditor5-custom-build 的假包供代码引入使用，但这个方法时而奏效时而报错，或是在张三电脑上能用而李四电脑上用不了。可以确保解决问题的方法是将该 ckeditor-dist 目录复制到 node_modules 当中，但是这样过于原始。于是决定有时间研究一下 NPM 打包。 Hello-richtext目标富文本组件包名叫做 Hello-richtext，它需要依赖我们自定义构建的富文本编辑器母版，所以首先将 ckeditor-dist 单独作为一个 NPM 包发布到我们团队的私有制品库中，就起名为 ckeditor-custom-build。 把 ckeditor-custom-build 加入到依赖中，原先组件中包含的所有文件都复制到 Hello-richtext 的代码目录中。利用 tsc 以 &quot;target&quot;: &quot;ESNest&quot; 的配置将 .tsx 格式的文件编译为 .js 和 .d.ts 文件，或许这也是最终在前端项目中被应用时的引入形式。 随后利用 Jest 和 React Testing Library 写下了如下的测试用例。 render.test.jsx12345678910111213141516171819202122232425262728293031323334import React from 'react'import { render } from '@testing-library/react'import { Form } from 'antd'import { CKEditorInput, CKEditorRenderer } from '../dist/CKEditorFormFields'import '@testing-library/jest-dom'Object.defineProperty(window, 'matchMedia', { writable: true, value: jest.fn().mockImplementation((query) =&gt; ({ matches: false, media: query, onchange: null, addListener: jest.fn(), // Deprecated removeListener: jest.fn(), // Deprecated addEventListener: jest.fn(), removeEventListener: jest.fn(), dispatchEvent: jest.fn(), })),})const TestForm = () =&gt; ( &lt;Form initialValues={{ renderer: '&lt;p&gt;Hello world!&lt;/&gt;' }}&gt; &lt;Form.Item label=&quot;Mock Input&quot; name=&quot;input&quot;&gt; &lt;CKEditorInput data-testid=&quot;input-field&quot; /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;Mock Renderer&quot; name=&quot;renderer&quot;&gt; &lt;CKEditorRenderer data-testid=&quot;renderer-field&quot; /&gt; &lt;/Form.Item&gt; &lt;/Form&gt;)test('test rendering', async () =&gt; { render(&lt;TestForm /&gt;).debug()}) 启动测试时遇到的问题只要富文本编辑器能够正常渲染就成功了，所以首次运行测试我比较保守，只定义了简单的表单并把自定义的两个组件作为表单项置入其中，并尝试将渲染结果用 render().debug() 的方式打印出来看看是否正确渲染。 但是启动 Jest 之后遇到了一系列问题，下面列举了我遇到的问题以及相关的解决方案。 无法解析 .jsx 格式文件，通过安装 @babel/preset-react 插件并创建 babel.config.js 应用该插件解决； 提示 ‘react’ 这个包没有导出 default，通过安装 @types/react 和 @babel/preset-env 解决，其中 babel 插件同样需要应用到配置文件中； 提示没有 window.matchMedia 方法，直接通过 Object.defineProperty 给 window 打上补丁（官方建议）； 无法解析 CKEditorFormField 中引入的 .css 文件，通过安装 identity-obj-proxy 依赖，并在 Jest 配置文件的 moduleNameMapper 属性中加入 &quot;\\\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot; 解决； 稍微麻烦些的就是上面4点，当然还有一些其他的必要的依赖也是需要安装的，这里给出局部 package.json，Jest 和 Babel 的配置分别如下： package.json1234567891011121314151617181920212223242526272829303132333435{ &quot;name&quot;: &quot;Hello-richtext&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;build&quot;: &quot;tsc&quot; }, &quot;keywords&quot;: [ &quot;richtext&quot; ], &quot;dependencies&quot;: { &quot;react&quot;: &quot;^17.0.0&quot;, &quot;@ckeditor/ckeditor5-react&quot;: &quot;^3.0.3&quot;, &quot;@ckeditor/ckeditor5-build-classic&quot;: &quot;^31.0.0&quot;, &quot;ckeditor5-custom-build&quot;: &quot;0.0.2&quot;, &quot;antd&quot;: &quot;^4.16.13&quot; }, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.17.5&quot;, &quot;@babel/preset-env&quot;: &quot;^7.16.4&quot;, &quot;@babel/preset-react&quot;: &quot;^7.16.7&quot;, &quot;@testing-library/dom&quot;: &quot;^8.11.3&quot;, &quot;@testing-library/jest-dom&quot;: &quot;^5.16.2&quot;, &quot;@testing-library/react&quot;: &quot;^12.1.4&quot;, &quot;@types/jest&quot;: &quot;^27.4.1&quot;, &quot;@types/react&quot;: &quot;^17.0.39&quot;, &quot;babel-jest&quot;: &quot;^27.5.1&quot;, &quot;identity-obj-proxy&quot;: &quot;^3.0.0&quot;, &quot;jest&quot;: &quot;^27.5.1&quot;, &quot;react-dom&quot;: &quot;^17.0.2&quot;, &quot;react-test-renderer&quot;: &quot;^17.0.2&quot;, &quot;ts-node&quot;: &quot;^10.7.0&quot;, &quot;typescript&quot;: &quot;^4.1.2&quot; }} jest.config.ts123456789export default { coverageProvider: &quot;v8&quot;, moduleNameMapper: { &quot;\\\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot; }, testEnvironment: &quot;jsdom&quot;, // 其他均为默认} babel.config.js123456module.exports = { presets: [ ['@babel/preset-env', {targets: {node: 'current'}}], ['@babel/preset-react', { targets: { node: 'current' } }], ],} 测试补全解决上一节遇到的问题之后，测试脚本可以顺利运行了，需要稍微补全一下测试用例。因为 CKEditorInput 从 ckeditor-custom-build 中加载 CKEditor 时采用了异步加载，所以用 rlr 的 render() 第一时间拿到的页面源码内显示该方法仍在加载中。通过 screen.logTestingPlaygroundURL() 方法可以获取 Debug Playground 的访问链接，用浏览器打开可以看到下图的内容，清楚明了。利用它还能获取如何查询页面元素的提示。 我期望两个组件都正常渲染，如果 CKEditorInput 组件需要异步加载，那么设置等待即可。测试用例补充为下面的样子： render.test.jsx (2)1234567891011121314151617181920// 防止加载时间稍长引发 jest timeout 的问题jest.setTimeout(60000)// ...test('test rendering', async () =&gt; { render(&lt;TestForm /&gt;).debug() screen.logTestingPlaygroundURL() await waitFor(() =&gt; screen.getByText(/hello world!/i), { timeout: 30000, }) await waitFor(() =&gt; { // 根据 debug() 的返回结果发现: // 可以通过获取 &quot;段落&quot; 这个工具栏提示字样来判断是否已经渲染出富文本编辑器 screen.debug() screen.getByText(/段落/i) }, { timeout: 30000, })}) 打包、发布完成测试完成后，利用 npm publish 命令将 Hello-richtext 发布到团队的私有制品库中，完成打包流程。在两个实际项目中安装 `Hello-richtext@0.0.1` 后，组件切实可用。 这次打包发布 React “组件库”的经历给了我几点体会， 首先是学习和实践了 React 组件的测试流程，加深了自己对于前端项目测试的理解； 其次让自己构建 NPM 包的流程更规范，之前发布的几个 NPM 包因为图方便求速度都没有写测试，没测等于没写； 在目前两个可能未来更多的项目开发中事实上地提升了代码复用度和开发体验，原先富文本编辑在各个项目间维护…挺麻烦的。","link":"/2022/03/12/PublishNpmPackageOfReactComponents/"},{"title":"我毕业了","text":"从 2016 年 8 月来到清华上学，到现在已经快要五年了。近期借着学校给给 2020 届补办毕业典礼的契机，得以穿上学士服跟朋友们同学们一起拍毕业照。课程学习生活暂告一段落，心里有很多感慨不吐不快。 大概从以下几个方面来聊一聊吧：专业选择给我的影响，清华之于我的意义以及自己的成长和收获。 专业选择用 697 分的高考分数结束了漫长枯燥的高中生活之后，我进入了清华大学软件学院学习，专业名称是软件工程。其实我填报志愿时对清华的专业不是很了解，在招生组老师和学长学姐的介绍之下选择了这个和计算机相关性最大的专业。（对没错，当时我们省不招计算机） 差距很大作为小镇做题家的零基础计算机小白，在入学之后很快地就感受到了和其他同学的差距，尤其是编程作业一些同学一小时完成而我要花上一下午甚至一整天的时候。清华的学期中学习压力很大，26 学分左右的课程基本上意味着一周五天都是课，每天都有作业要做。当时编程能力十分落后带来的影响导致一些基础数理课也有些吃紧，好在最后都没有触到挂科这个的情况。我经常问我室友或者年级里的其他同学作业问题，怕总是问一个同学把他问烦我就在一些同学之间来回换着问。在这里要由衷感谢几位大神和我的室友们。 兴趣渐浓我从小就对电脑这东西比较感兴趣，不管是电脑游戏还是一些电脑应用，总是喜欢自己捣鼓。来到软件学院也算是得偿所愿，尤其是很多课程的大作业（或许有的学校叫做“课程设计”）都是写游戏，很对我的胃口。本科应该一共写了 3 个游戏，虽然质量都很差，但是写的过程还是快乐的。我发现我喜欢自己造一些东西出来，写一个游戏、发布一个包或者库、开发一个系统这些都是比较吸引我的事情。比起考试这样的紧张刺激的课程考核形式，开发游戏或者系统这样成果看得见摸得着的事情，让我觉得更加踏实。可能总的来说我还是比较希望规避不确定性，拥抱更多的确定性吧。或许这也从一个方面体现了其实我不是天赋型选手，勤能补拙应该是我需要考虑的第一要义。 大三上了《软件工程》这门课，和另外三个队友真刀真枪的开发一个系统：需求分析、原型设计、技术选型、数据库设计、功能实现、系统测试、文档撰写这些软工流程我们完整地体验了下来，最后课程成绩比较好。我也发现了我确实挺喜欢写代码的。后来的数据库、计算机网络等课程，包括后来到旷视实习的经历都进一步加深了我的兴趣。让我逐渐明晰喜欢的事情。 现在开发的琴房预约系统目前已经上线，虽然之前的队友不太有热情来维护这个项目了，但是就算是我一个人我也会把这个项目好好维护到我自己毕业；作为辅导员，我自己开发了一个系统给自己和同学们用来查询成绩和排名，也给其他辅导员开发了一个计算排名和查询成绩的网站；面对新颖的、高效的、优雅的技术我总是会心生向往，很难控制自己想去了解一下的冲动，可能就是喜欢折腾吧。每次想尝试一个东西我都会在 github 上创建一个叫做 XXX-taste 的 repository，现在类似的 repo 好像已经有十来个了。我觉得目前我对我所做的事情还是保有相当的热情，也愿意为之投入更多的时间。 清华之于我在清华待了五年，要说它给我带来了什么或者让我失去了什么可能很难用言语梳理出来，列一下现在能想到的几点吧： 清华给我上的第一课就是接受平凡，在高中三年大大小小的考试中我很少考第二名，但是到了清华要接受自己是个计算机小白，排名只在中等水平的事实。 如果拿不了95分，那么80分也挺好，好好完成课业任务，心态要稳。与其跟别人在成绩上卷，不如做自己感兴趣的、有意义的事情。 大学里学的不只是课内知识，更要学习待人处事的方法，增强面对挫折的勇气，拓宽所处世界的视野。 朋友很重要，尤其在校园这个小社会当中，他们就是自己的靠山了。 入党是一件非常庄严的事情，如果不是明确清晰地认同党的路线和纲领，请不要申请入党或者发展这样的同学。 不要总是窝在寝室打游戏，户外真实的风和阳光比游戏中的虚拟更加美好。 总结和展望大学里拿过一些4.0，也险些挂了某些课程；当过班长、学生会主席，现在还在继续做着辅导员这份学生工作；感情方面谈过异地恋、异国恋，当过舔狗，被劈过腿。生活体验可以说是非常丰富了（甚至有些离谱），从这些经历中得到了什么成长呢？得到了较强的心理承受能力吗哈哈，挺过挂科边缘的压力还是需要一定的承受力的；一边忙着各种课程作业，一边手忙脚乱地筹办学生节也是很难得的体验，更何况我们还产出了很多优秀的文艺节目；谈的几段感情都是异地，美好的回忆当然是有的，但是遗憾更多吧，这几段经历都无一例外地让我变得更加成熟了。 距离完全跃入人海还剩下不到两年的时间，通过这五年的时间我应该能够以更好的姿态来迎接未来两年的挑战，也希望剩下的两年里可以多做些自己想做的事情，不留遗憾。冲鸭~","link":"/2021/06/29/Graduation2021/"},{"title":"暑期的生活啊","text":"已经实习四周了，学院安排的实习期已经只剩下一周，但是直到这两天公司 Buddy 才给我安排了一个比较重要且连续的工作，让我有点左右为难：下周之后我到底还去不去呢？之前四周的工作都是延续暑假前所做，多是一些较零散、不系统的碎活儿，其实这样的安排确实容易让人觉得枯燥无味，缺乏意义和价值。“摸鱼”让我觉得内心有愧，如果要做自己的事情，为什么不回学校呢？ 一周五天上班的日子让我分外珍惜周末的两天，因为周中下班回到宿舍已经快晚上8点了。这一晚上一般就会在我是要刷题，还是要看一些资讯，还是看B站这样的纠结之中过去，第二天有点后悔，但是回来之后又重复前一天的过程。究其根本，我觉得是因为我暑假想做的事情太多了。 实习 刷题 社工 上线小程序 写诸如这篇博客的东西 学习一些奇妙有趣的东西 blabla（我觉得这个引用框好好看 暑假我也更加清晰地认识了我的本质，我对不了解的事物很难提起兴趣，但是一旦喜欢某件事物之后就会开始不断的去了解去接触，就是这样一个循环。所以，我的生活好小啊。 看到手机上给自己的警言：“想的多了，做的就少”，这是高中时期自己给自己打气用的，希望自己能够心无旁骛地做自己该做的事情。但是来到大学之后发现，没有明确的事情是那么的该做了，只有想做的事情比较明确，然而想做的事情太多，在纠结之中又会不经意掉入“想太多”的境地。给自己定一个小目标吧，8月里把心沉下来，否则这个暑假将和去年暑假一样浮躁。","link":"/2019/07/27/SummerVocation/"},{"title":"记2021年小程序大赛","text":"从本科到现在总共参加过三次微信小程序大赛，前几天刚完成赛区决赛的答辩，心想着以后应该都不想再参加了，于是想记录一下这次的参赛经历。 2018 和 20202018 阴差阳错微信小程序从 2017 年正式上线博得广大关注，在第二年 2018 年春季，微信就推出了全国高校微信小程序开发大赛，吸引了很多大学生参加，我就是其中一个。正在读大二的我报名了一位学长组织的 SRT(Student Research Training) 项目，原本的题目是要开发一款在线客服平台。然而当时已经把项目申请里面提到的客服平台提前完成了，于是我们真正做的就变成了小程序。甚至还用这个小程序参加了第一届的微信小程序大赛。 虽然做的东西和项目选题没太大关系，不记得当时具体开发的小程序有些什么功能，最后也没有拿到什么奖项（但隐约记得有证书）但通过这项目我第一次接触到了 Javascript、Vue 和微信小程序这些新东西，也认识了几位非常靠谱的队友（在之后的课程作业组队当中也延续了组队），我的收获不少，所以还是非常感谢这次项目经历的。 2020 毫无波澜第二次是在 2020 年用课题组的一个项目参加的比赛，进了华北赛区的决赛，但着实因为我们准备的不够充分而且其他队伍的作品也比较优秀，我们最终也止步于此。得到这个结果我不是特别遗憾，因为我在准备赛区答辩时就有了心理预期，所以说这次参加比赛的内心感受就是毫无波澜吧。 2021 年小程序背景如果说对第二次参加比赛的小程序我只是一知半解，那么今年参加比赛的作品我就是了如指掌。因为这是我们大三学期上《软件工程》课程时做的课程作业，它的背景是给学校艺教中心开发一套能够方便琴房管理和琴房预约的系统。 本来以为这个作业像往常那样只停留在“作业”这个层面，不会有实际使用价值。但是授课老师认为我们组做得不错，于是真正帮我们联系到了艺教中心的老师开了个会。会上艺教中心老师对我们的系统非常满意，这让我们喜出望外，但同时也给我们提了一些问题，例如还没有接入清华校内统一身份认证接口、没有接入校内支付接口等等，但我们相信后面都可以解决的。 那个学期过得很快，我们组的作品获得了 A 的评分，但是我们小程序的上线过程却不那么顺利：因为要接入校内的接口，我们需要把程序部署到校内的服务器上，之后经历了漫长的申请服务器、申请域名、申请安全扫描、申请证书、申请身份认证接口权限、申请财务接口权限等流程，期间还经历了新冠疫情爆发回不了学校的一个学期以及需求变动重新开发新模块… 功夫不负有心人，终于万事俱备申请上线了，那报名参加比赛吧。小程序名字叫做“掌上艺教”。 定位和需求分析小程序的定位掌上艺教是一个涵盖清华大学艺术教育中心琴房租赁和课程管理的一站式系统。面向三类不同的用户，他提供不同的功能。面向在校师生、教职工和居民，掌上艺教提供了校内外两种安全高效的身份认证方式，认证用户可查看琴房空闲时间、预约琴房、在线付款、查看订单和核验电子票等；面向艺教中心开课教师，除了琴房预约外，还提供课程申报、志愿填报等功能；艺教办公室老师可以使用系统的管理后台应用对琴房租赁和课程业务进行管理； 需求痛点清华大学艺教中心历史悠久，业务众多。它每年开设艺术类选修课程 160 门次，指导学生艺术团 12 支队伍共 1300 名队员的排练，同时需要管理校内众多文艺场馆。 但是艺教中心目前的业务存在信息化不足、办公效率低的问题。表现在具体的业务当中有以下两个方面： 在琴房业务中，艺教中心采用“办卡储值，打孔消费”这样比较原始的机制，容易造成浪费和卡片丢失的问题；同学们要想预约琴房只能亲自去艺教中心询问是否有空余的琴房，这样费时又费力；另外，老师如果想查询、统计和备份数据或者是进行用户管理就很难办到了。这样的局面对于老师管理琴房和同学预约使用琴房来说都非常麻烦。 在课程管理上，开课教师和办公室老师们通过邮件和微信沟通开课意向和期望志愿缺乏系统性，而且在邮件或微信往来过程中信息很容易丢失；最最要命的是，收集到课程信息后，办公室老师需要把 160 门课程的开课时间、上课地点手动地排在一张 Excel 大表里。手动操作出错的概率很高，但是一旦出错会给开课教师、艺教中心和学校教务带来很大的麻烦。下面这张图片就是手动排课时用的表格截图，当然这只是冰山一角。 我们的系统就是要解决上述的痛点。 功能介绍我们开发了掌上艺教小程序和与之配套的两个管理后台（分别对应琴房和课程业务），其中小程序的主要功能有： 身份认证：对校内外用户分别进行相应的身份认证，对接清华大学统一身份认证； 查看课程表：开课教师能够查看当前学期自己开课的课程表； 课程信息查看：开课教师能够查看自己或者其他教师所开课程的信息； 开课意向填报：开课征集期间，任课教师可以在小程序中填写开课意向和排课志愿； 排课信息确认：艺教办公室老师在后台生成排课表之后，开课教师能够查看并确认课表是否符合预期； 琴房浏览：使用掌上艺教能查看艺教中心对外开放租赁的琴房列表并查看它们的信息如空闲时间、租赁单价、位置简介等； 支付定金：预订琴房后可在线支付定金，完成支付后将获取订单核验二维码； 代金券折扣：支付定金时可使用代金券抵扣指定额度的琴房定金； 电子票核验：琴房入检人员可以扫描支付完成的订单二维码核验信息并准入。 课程管理后台的主要功能有： 课程信息管理：可以对系统内课程信息进行增删改查，包括但不限于某一学期内开课教师所创建的课程； 教学场地资源管理：可在系统中维护教学场地包括教室地点、教室容量、教室属性等在内的信息； 排课表生成与调整：开课教师提交完成排课志愿后，系统将根据开课教师的志愿信息和在系统中设置的权重策略，对所有课程进行自动编排。自动生成出的课表可以进行手动调整； 后台账号管理：可以对人员进行账号管理，包括启用/禁用账号、账号密码重置及权限管理； 教师名单维护：通过维护教师名单可控制哪些用户能够使用排课系统； 通知公告：在管理后台可使用富文本编辑器编辑发布通知公告，并查看教师们的阅览情况（已读或者未读）。 琴房管理后台的主要功能有： 琴房信息维护：可以对琴房列表和琴房信息进行维护，包括琴房名称、位置、头图和占用规则（规律性占用）等； 订单管理：可以通过姓名、手机号、证件号、预约时间段、预约琴房等条件进行订单查询与统计，并查看或修改订单详情； 用户管理：可通过姓名、手机号、证件号等字段查询用户详情，进入用户详情可将用户纳入黑名单、查看用户的订单和代金券等； 用户组管理：通过设置用户组对琴房的预约权限、租赁单价和用户列表，可以实现用户的权限管理和租赁单价管理； 代金券管理：可向指定用户手动发放代金券或向指定用户组周期性发放代金券用于琴房定金抵扣。 系统架构 系统架构方面，我们选用了 Vue.js 作为 Web 应用的开发框架，小程序则使用微信原生框架进行开发。前后端通讯方面我们使用的是 GraphQL（可能需要科学上网），这和传统的 RESTful API 相比有很多优点，在这里就不展开说了。后端则借鉴了流行的微服务架构的思想，把两部分后端服务进行了实现和部署上的拆分（可以看到两个后端服务的开发语言都不一样），同时两个服务都采取了容器化的部署方式，极大地降低了开发和运维成本，同时减少了系统整体不可用的风险。 后端服务拆分实现部署的开发方式我们还是第一次采用，这确实给我们的系统带来了很高的灵活性，技术栈的选择也更加自由。而且，通过实现服务间通信，各个实体之间的交流更加密切，可以做到更多有趣的事情。例如微信小程序用户的登录状态存在一个服务 A 上，当另一个服务 B 也需要用到该状态时，可以通过直接向 A 发请求拿到相应的信息。在我们的系统当中，服务间通信是直接发 HTTP 请求，以前实习时做的系统用的是 gRPC 和 protobuf 来完成的。不过本质都差不多。 比赛结果赛区决赛当天晚上其实就已经出结果了，我们的小程序是华北赛区第 5 名，是三次比赛当中名次最高的了。虽然可能进不了全国决赛，但是我还是能够接受这个名次的。前几名的作品确实有着非常好的产品定位（例如第 2 名“帮你学拼音打字”目标是帮助中老年人学习使用手机拼音打字）和非常高的完成度（例如第 1 名“方仔照相馆”），我们的小程序作为一款在校内使用的半开放式小程序，格局比起他们的来说还是小了不少。 最后的感想2021 年的微信小程序大赛其实已经稍见颓势，从取消微信小游戏赛道这方面就能看出微信不太重视这场比赛了。参赛作品的多样性和创新性也随着时间的推移逐渐降低，越来越难以见到让人眼前一亮的好的作品。所以比赛不再受重视也不奇怪，微信一开始推出这个比赛就是想借助有热情有活力的大学生群体带动小程序的市场，而到了 2019~2020 年微信小程序其实已经占据市场主导地位，不再需要依靠比赛来扩大影响力了。 另外比赛的风气也不太好，2020 年的华北赛区决赛好像就出现了相互举报的状况，有点无语也有点无聊。不知道明年这个比赛还会不会办下去，不过就算继续办我也不太想再参与：我的热情被小程序开发消磨掉不少，也没有太多创新的点子想付诸小程序开发。小程序对于用户来说有着很不错的体验，但是对于我们开发者来说小程序是处处受限的前端应用，这也不能用那也不行。没错现在我已经不想“用户至上”了，我想做更纯粹一些的开发。","link":"/2021/07/20/TheThirdMiniprogramCompetition/"},{"title":"如何相对优雅地使用 GraphQL","text":"关于 GraphQL，它的官网(需要科学上网)是这样介绍的： GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 作为 RESTful API 的竞品，GraphQL 从开源之初就备受关注，一是因为它是由 Facebook 开源的项目，二是它挑战了 RESTful API 的地位，这是很关键的一点。RESTful API 利用 URI 的具体内容和请求方法来区分请求的资源或者方法，其中的资源 URI 容易与路由路径产生混淆和重复；资源数量达到一定的数目之后，如何给资源 URI 起名或许也是一件困难的事情。而 GraphQL 则鼓励开发者将所有需要请求的信息显式的写在请求体当中，精确到具体的字段，不多也不少。 我参与的几个项目都是用 GraphQL 作为 API 的基础，我总结出了一个在前端相对优雅地使用 GraphQL 的方法。这篇博客不讨论 GraphQL 的基本概念，主要介绍这个方法。（为省篇幅，这篇博客里面的代码均不做异常处理） GraphQL 的原始用法GraphQL 在前端的表现其实并不新奇：根据定义好的 schema，前端用 post 请求将 query string 和可选的 variables 包装在 body 当中传给后端的某个节点，后端正确响应之后以前端查询的结构将数据返回。 利用基础方法那么根据这个基础我们就能够想到在代码中的用法了，首先在 api.js 中定义一个请求的基础方法： api/index.js1234567891011121314export async function graphql(q, vars) { const resp = await $axios({ method: 'post', url: BASE_URL + '/api/graphql', data: { query: q, variables: vars, }, headers: { token: getYourToken(), }, }) return resp.data.data} 然后在所有需要请求的地方使用这个基础方法就可以完成 graphql 的请求，可以直接把请求参数嵌在具体的请求方法里面，也可以使用 variables 的方法（但这样会需要在字符串中多写些变量定义）。 index.js1234567891011121314151617181920212223import { graphql } from './api'async function getPerson1() { const resp = await graphql( `query { person(id: ${id}) { id name address age gender mobile } }` )}async function getPerson2() { const resp = await graphql( `query ($id: ID!) { person(id: $id) { id name address age gender mobile } }`, { id } )} 体验糟糕的查询字符串或许你觉得上面的方法还可以接受，但是如果变量中存在数组、枚举值和布尔值时，直接在 query string 中插入变量的体验就会变的很糟糕。像下面这样，我这辈子都不再想见到这样的写法。 index.js12345678async function heyGuys() { const guys = ['alice', 'bob', 'carol', 'dave'] const resp = await graphql(` query { heyGuys(guys: [${guys.map((n) =&gt; '&quot;' + n + '&quot;').join(',')}]) } `)} 统一管理查询字符串在逻辑代码中写大量的 query string 不太利于维护，为此可以将所有字符串分类整理好统一管理。例如放在某个 documents.js 文件内，其他地方需要请求的时候直接从该文件导入即可。这样可以在真正的业务逻辑中避免大量的字符串。 api/documents.js1234567export const getPersonDoc = ` query ($id: ID!) { person(id: $id) { id name address age gender mobile } }` 问题仍然存在上面统一管理查询字符串的体验还凑合，但是真正开发起来就会发现有以下几个问题绕不开： 我如何知道一个字符串对应的变量应该是什么？只能查看字符串本身的定义； 我写字符串的时候如何获得代码提示呢？还是说我只能对着后端的 schema 逐字段慢慢写呢？ 既然都统一管理了查询字符串，是不是还得再封装一层查询方法呢？这样业务逻辑处的代码还能更省。 如果都用字符串如何使用 Fragment 呢？（或许可以看一下 graphql-tag） 更好的方法：代码生成如果完成一个请求需要先写查询字符串，再封装一个关于这个查询字符串的请求方法，开发效率不会很高。可以看到上面的代码很多都是琐碎且平凡的，既然如此，可以尝试生成代码。为此我们需要了解以下的包或者插件： @graphql-codegen: graphql 代码生成器，一个 npm 包。通过定义的 schema 和 operation 生成包含请求方法的 typescript 文件； GraphQL: vscode 插件，用作写 .graphql 文件时的自动补全； 配置 @graphql-codegen按照该包官方文档的指示进行安装配置即可，不需要太多的配置。其官网上还有下图所示的 live example，非常容易弄懂。 我在开发中一般会配置两个代码生成配置文件，一个用于同步后端、生成代码补全所依赖的 schema 文件，一个用于生成 operation 对应的请求方法。如下是两个配置文件的大致内容。 schema.codegen.yml12345generates: ./graphql/schema.graphql: schema: 'BASE_URL/api/graphql' plugins: - schema-ast operation.codegen.yml12345678generates: ./api/demo.ts: documents: './graphql/operations.graphql' schema: 'BASE_URL/api/graphql' # 或者直接使用 './graphql/schema.graphql' plugins: - typescript - typescript-operations - typescript-graphql-request 配置文件中的 plugins 配置项是关键。schema.codegen.yml 中的 schema-ast 是生成 schema 的 graphql 文件；operation.codegen.yml 中的 typescript-* 则是生成请求方法所依赖的插件。我这里给出的是使用 graphql-request 的例子，graphql-request 是一个轻量、简洁，支持 ts 和 promise-based API 的 GraphQL 客户端，在前后端都能使用。 生成请求方法所依赖的插件根据项目特点选定，例如 graphql-request 这个插件我用在 Vue2.x 的项目当中，而在 React 的项目中我是用的插件是 React-Query Hooks。每个插件对应的基础库的特点不一样，生成的代码风格也不尽相同，根据需要灵活选择即可。 编写 operationsoperations 顾名思义就是操作，在 GraphQL 里面操作分为 query 和 mutation，编写具名操作会被 @graphql-codegen 转换成为请求方法。下面给一个例子： schema.graphql1234567891011121314151617181920212223enum Gender { Female Male}type Person { id: ID! name: String! address: String! age: Int! gender: Gender! mobile: String!}type Query { persons: [Person!]! person(id: ID!): Person}type Mutation { setPersonGender(id: ID!, gender: Gender!): Boolean greet(id: ID!): String!} operations.graphql1234567891011121314151617181920query getPersons { persons { id name }}query getPerson($id: ID!) { person(id: $id) { id name address age gender mobile }}mutation sayHello($id: ID!) { greet(id: $id)} 因为用了 vscode 的插件 GraphQL，所以在写 operations 的时候其实是有代码补全的，开发体验比较好，下图是在 vscode 上的代码补全，在 jetBrains 的 IDE 上面的代码自动补全应该会更完善。 生成 typescript 代码写完上面的 schema 和 operations 之后，运行 graphql-codegen --config operations.codegen.yml 即在 ./api 目录下可生成一个 demo.ts 文件。其中包含了下面这样的代码： api/demo.ts123456789101112131415161718// ... 省略了很多const defaultWrapper: SdkFunctionWrapper = (action, _operationName) =&gt; action();export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) { return { getPersons(variables?: GetPersonsQueryVariables, requestHeaders?: Dom.RequestInit[&quot;headers&quot;]): Promise&lt;GetPersonsQuery&gt; { return withWrapper((wrappedRequestHeaders) =&gt; client.request&lt;GetPersonsQuery&gt;(GetPersonsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPersons'); }, getPerson(variables: GetPersonQueryVariables, requestHeaders?: Dom.RequestInit[&quot;headers&quot;]): Promise&lt;GetPersonQuery&gt; { return withWrapper((wrappedRequestHeaders) =&gt; client.request&lt;GetPersonQuery&gt;(GetPersonDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPerson'); }, sayHello(variables: SayHelloMutationVariables, requestHeaders?: Dom.RequestInit[&quot;headers&quot;]): Promise&lt;SayHelloMutation&gt; { return withWrapper((wrappedRequestHeaders) =&gt; client.request&lt;SayHelloMutation&gt;(SayHelloDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'sayHello'); } };}export type Sdk = ReturnType&lt;typeof getSdk&gt;; 可以看到 getSdk 这个函数会返回一个对象，其中包含了刚刚在在 operations.graphql 中定义的几个操作。这样就从类型上锁定了这个方法的名字、参数以及返回值。这对于项目维护和开发来说无疑都是利好的。 使用生成的代码因为真正使用的请求方法肯定是要鉴权的，我们需要再调整一下生成的代码，看到上面 demo.ts 中的 defaultWrapper 函数了吗？我们只需要在调用 getSdk 时传入自定义的 Wrapper 即可。下面给个例子： api/index.ts123456789import { getSdk as getDemoSdk } from './demo'const getClientOptions = () =&gt; { return {}}const apiWrapper = async &lt;T&gt;(action: (headers?: Record&lt;string, string&gt;) =&gt; Promise&lt;T&gt;) =&gt; { const headers = { 'token': getYourToken() } return await action(headers)}export const demoClient = getDemoSdk(new GraphQLClient('/api/graphql', getClientOptions()), apiWrapper) 在需要用到的地方只需要导入 demoClient 即可，我们再用几行代码重写一遍上面的 getPerson 函数： index.js1234import { demoClient } from './api'async function getPerson3() { const resp = await demoClient.getPerson({ id })}","link":"/2021/07/23/UseGraphQLElegantly/"},{"title":"2022年我希望...","text":"新年的元月已然过半，但直到现在我才能说我完成了上一年的工作。我一直在追求“忙的时候闲一点，闲的时候忙一点”的从容，这一年大部分时间是保持着这个状态的，让我非常欣慰。但是真正从学生身份蜕变成“开发者”“软件工程师”（或者“社畜”？其实即使是自嘲我也不太喜欢这个词），还是有着截然不同的感受和体会的。对于2022也有着无数的憧憬。 2021上半年：课程时代尾声2021年上半年我研一，为了一年上完所有的课我这个学期仍然是课程满满的，与此同时课题组的项目也开始安排给我。在课程任务和项目进度的双重压力下，我会想着“尽快结束这样的生活节奏，争取早日回归生活的正轨”，但这个状态持续一小段时间之后我逐渐与之和解了，与其认定只用考虑学习的生活是正轨，不如接受多线程地生活才是当下社会当中每个人都需要具备的基础能力这个事实。 那么话又说回来，我认为我的多线程能力还是不错的，因为在主业之外我一直以来都或多或少地参与到学院、学校的学生工作中。在相对一板一眼的计算机知识、代码编写和需要社交活动的谈话开会、学生事务之间频繁切换也没有被我归入困扰我的事情当中。这样长期以来的“训练”让我对社交行为本身脱了敏，甚至有时还会主动发起社交活动；也让我对“同时处理很多事情”这个现象习以为常。 随着课程结课，我有了更多的时间可以投入到课题组项目里。我在课题组的工作投入在一定范围内是正反馈的：投入时间增加产出增加 –&gt; 工作产出增加 –&gt; 安排给我的工作增多 –&gt; 投入时间增加。实验室有位同学开玩笑地说我是“劳模”，每天都早早来到实验室但很晚才回寝。这个状态从暑假一直持续到现在，我自己是乐在其中了。我在课题组里承担的工作让我拥有了难以替代性，在这个过程当中我收获的知识、激励还有认可都成了我齿轮转动的润滑剂——即使有的时候这种难以替代性也带来不小的压力。这个反馈过程却有点像我高中的学习历程：认真学习带来的收获主、客观上都有助于我继续认真学习，学习换成工作也受用。我觉得这样的状态是比较难得的，我享受这一状态。Sybil说我很幸运，学的专业做的工作都是自己喜欢的，所以能够保持自驱，我觉得确实是这样。 2021下半年：偶然与想象喜欢记录为什么不拍照呢？我在5月入手了一台富士相机，并立马带上它去了青岛。不深挖构图角度也不用Photoshop，光是拨动相机滚轮，摁下相机快门在任何一处拍下软糯或嶙峋的云彩，波光粼粼的海面还是叶影斑驳的片片树荫、铺满和煦光影的高矮楼房，都让我感受到极为愉悦。虽然没有太多机会到外面旅游，但在学校里面简单记录四时风景也是很好的体验。 8月开始捡起闲置已久的吉他，在琴包里放了近两年，音孔部分的琴弦竟然有些锈迹斑斑。完全从零开始学，在不懂乐理的情况下，我照着吉他入门教材学习了几个基本的和弦。弹唱的曲子从教材里比较简单的《送别》到自己感兴趣的《杀死那个石家庄人》《平凡之路》等等，也逐渐意识到自己水平有限需要加强练习。下面这张图虽然没有标识我的所有练琴记录，但可以大致体现我的练琴状态：有段时间练习比较密集，有段时间又比较松懈，指尖和食指侧的茧长了又消。以前听人说吉他很简单，可能跟“Python很简单”道理一样吧，我到目前为止我学到稍微深入一点的技巧也只有横按和泛音而已。 11月我跟Sybil恋爱了。记得那天我怀着难以压抑的心情写下了一封两页纸的信，信的内容我已经不能全部回忆出来了，但那份心情却恍如昨日。从系馆回到宿舍区时已经是凌晨，那天晚上的风不同寻常的湿润，月亮在薄雾后面显得朦胧，在分别之际我扭捏地叫住她说“我想跟你说件事”，说完之后把信给她，我们在一起了。恋爱改变了我的生活轨迹，我依旧每天努力工作，但生活的一切都被她点亮了，我很感谢她。我们从两个地方相向奔赴，“在离人群不远的地方携手同行”。 这半年没有课程没有作业的时间里，原本以为会枯燥乏味的生活却过得很丰富，果然生活是需要偶然与想象的。 2022的小目标2022年还剩下350天，剩余的95%时间里我希望自己可以有更多从容不迫、处变不惊的心态和能力，有“彼可取而代也”、不惧跃入人海的傲骨和锐气；对待喜欢的人要满怀热情，对待讨厌的人要爱憎分明。之前总说“想的多了，做的就少”，务虚的话简单说说就好，人不能总活在空中楼阁。给我的2022定几个务实些的小目标（排序不分先后，包括但不限于）： 每个季度至少读两本非技术类书目； 每个月至少更新一次博客，类型不限； 每两周至少看一部非所谓商业片的电影； 每周至少锻炼一次，有氧/无氧、室内/室外均可； 协助所带班级内每位同学捋清未来职业发展规划； 学习乐理，能够转换吉他谱和五线谱； 开源至少3个代码仓库，做些有意思的开发。 以上。2022来年再会。","link":"/2022/01/15/SomethingFor2022/"},{"title":"聊聊微信小程序及其框架","text":"为什么是微信小程序微信很早就有一套专用的JS-SDK在微信客户端上面使用，其开放了录音、二维码、地图、支付等几十个 API，能够支持微信服务号的运转，当时大部分支付、扫码等功能的对接方都是这样的服务号。但是在 2016 年 1 月 11 日微信之父张小龙表示服务号还不够优秀，微信正在研究一个新的服务形态，起名叫做“微信小程序”。在 2017 年 1 月 9 日，第一批微信小程序低调上线，而选择这一天也是为了向 iPhone 1 代的发布致敬。 很快，微信小程序依靠微信的庞大用户量迅速的占领了市场，其他各个大厂见势相继效仿，但是从目前来看它们都很难和微信小程序再抗衡了——不管是用户数量还是开发者数量。这倒也不太奇怪，这种行业往往都是快鱼吃慢鱼不是大鱼吃小鱼，emmm…不过背靠腾讯的微信也不能说是小鱼吧。 为什么要写微信小程序首先想说的是，微信小程序的生态是比较混乱的，开发起来有一点难受，有不少情绪比较激动的开发者直接说微信小程序就是“s**t”，我也能够理解其中的一大部分感情。 我从大二参加微信举办的第一届大学生微信小程序大赛到现在已经有 3 年了，这期间虽然不是一直在开发小程序，但是每年都会或多或少因为课程或者是项目的原因接触小程序开发，所以对微信小程序还是有一定的了解的。 小程序非常不好写。我觉得有以下几个方面的原因: 一个页面(Page)拆成四个文件这样分散的组织形式让我觉得有点难受，有的人可能会说这是关注点分离，但是我觉得 Vue 在单文件内拆成多个部分的形式可能更好一点，一个重要的事情值得注意，关注点分离不等于文件类型分离。而且你说一个叫做page的页面，它下面的四个文件名是叫page.wxml好还是叫index.html好呢？ 微信开发者工具非常不好用，首先它很占内存，内存小的机器上运行微信开发者工具一段时间后会出现奇奇怪怪的问题，因为遇到的次数有点多也没有特别记得，在这里也说不出来了。 因为在微信的生态里面，处处都要依照微信的规矩来进行开发或者运维（这倒也没办法），用某某接口需要是某某类目的小程序，需要有某某资质的主体等等……申请接口、申请上线等种种流程都十分繁琐。 官方文档有些混乱，而且最近两三年内没有进行过较大的更新改进。 但是有的时候又不得不写它，因为它对用户更加友好。如果换作是我的话，我也不会为了去餐厅点餐或者是在奶茶店买奶茶专门下载一个 App，为了扫健康码就更不会。微信小程序就是为了替代微信服务号这样的“用完就关”的应用场景的，开发的时候把它当作微信服务号 2.0 来开发就好了，不要提高自己的心理预期以为自己是在开发一款 App。这样想的话，开发起来就会好接受多了。 小程序框架浅析逻辑层和渲染层 微信小程序通过微信客户端(Native)这一桥梁向外界服务器发送请求和接受响应、调用手机本地接口(拍照、上传文件等)。小程序分为了渲染层和逻辑层，小程序页面的 WXSS、WXS 和 WXML 运行在渲染层，而 JS 运行在逻辑层。WXS 是专门给小程序推出的一个脚本语言，是 JS 的子集，运行在渲染层执行一些简单的数据处理任务，据官方文档说使用 WXS 在 Android 上没有太多性能提升，但是在 iOS 上用其执行相关任务能加速 2~20 倍。 微信小程序的渲染层与逻辑层也通过 Native 进行通信，比如渲染层将触发的事件传输到逻辑层，逻辑层将更新的数据传输到渲染层等等。可以看到上面这张图里渲染层分了很多个 Webview，其中每个 Webview 都代表了一个小程序页面。 WXML 文件其实是标识了页面的元素及其相互关系，在微信小程序的编译过程中，WXML 文件会被编译成为 JS 对象用来在渲染层维护一个虚拟的 DOM 树。通过与逻辑层的数据进行组合，形成一个数据和结构都完整的虚拟 DOM 树用以渲染。每次在逻辑层调用 setData 方法时，逻辑层都会将这个消息传输到渲染层，渲染层通过对比发来的数据与之前的数据，将有差异的数据应用到 DOM 树上，从而进行更新渲染。 目前市面上有许多的小程序开发框架，如 Taro、Uni-App、mpvue、WePY 等，有实验显示使用小程序框架进行开发会使得小程序性能提升，其中很大一部分原因就是开发框架会对 setData 的调用进行优化，减少逻辑层和渲染层的实际通讯次数，从而提升性能。 而采用渲染层和逻辑层的架构主要是为了阻断页面渲染和逻辑处理，从而加强监管、提升性能。 小程序页面生命周期 从微信小程序官方文档上面的生命周期图示(方便起见，我把纵向的长图拆成了左右两个部分)可以看得很清楚，逻辑层与渲染层分别进行初始化。 逻辑层执行完 onLoad 和 onShow 两个生命周期函数之后，等待渲染层初始化完成的通知； 逻辑层收到通知之后，将初始数据传输给渲染层，渲染层拿到数据进行首次渲染之后再次通知逻辑层，让其执行 onReady 生命周期函数； 执行完 onReady 函数之后，小程序就处在 Active 状态了； 如果小程序在激活状态下被最小化到微信的后台或从后台被唤起，则会调用 onHide 和 onShow，如果在激活状态被关闭，则会调用 onUnload (一般不会用到)。 小程序从后台被唤起时的启动叫做热启动，第一次打开或者距离上一次打开已经过去了足够长的时间时叫做冷启动。他们进入页面生命周期的位置不同，开发的时候需要格外注意一下。 我自己的小程序开发方法开发微信小程序有许许多多的方式，最原始质朴的方式就是直接使用微信开发者工具进行编码和调试，这是我在大二的时候使用的方法。我已经很久没有用过这种方法了，但是它至今仍然给我很不好的回忆，究其根本主要是因为 IDE 实在是太难用了。 后来使用 WebStorm 来进行微信小程序编码，但是发现我自己的笔记本电脑(18 年老电脑了)同时带 WebStorm 和微信开发者工具两个“重型” IDE 实在是有点吃不消，遂作罢。 后来接触到了 gulp 这个前端工程化工具，可以让编码过程更加自由，尤其是能够使用 sass 等 css 预处理器，让我觉得开发起来清爽了很多。目前我是用VS Code进行编码，同时使用了minapp, Live Sass Compiler这两个插件，能够原地使用 sass，也没有增加过多的复杂性，很符合我自己的“编码哲学”hhhh。 我在写代码的时候一直觉得奥卡姆剃刀原理是真理，可以不要的就一定不要。这样的想法使得我在之前的开发中从没有想过用小程序开发框架，“一次编码自动构建多个平台的小程序”，我需要开发的只有“微信小程序”这一个而已，不需要增加那么多的复杂性。 但是最近越来越受不了小程序复杂的设计了，尤其是写惯了 Vue 再来写小程序，简直就和降智了似的。 之后我应该会看一些小程序框架的文档，先从 Uni-App 和 WePY 这两个开始吧。Uni-App 是用 Vue 语法开发小程序的框架，支持一键生成多端小程序。而 WePY 则是微信官方推出的小程序开发框架，仅支持微信小程序。这也算是立了 flag 吧。","link":"/2021/01/21/WechatMiniprogram/"},{"title":"当我写H5时，我到底在写什么？","text":"背景“活动宣传写个H5就可以了”，”学生节不如做一个H5小游戏吧，比如之前那种学堂路躲避乌鸦“……在这几年的学习和生活中我听到过很多次H5，也真正看到过、使用过、制作过H5，但是我对H5这一个词的真正定义还是不太了解。它给我的直观印象就是在手机上运行的、包含许多动画甚至音乐的纯前端/弱后端页面，最常见于微信群、公众号和朋友圈，或许这也是大多数人对其的印象。对自己接触的东西一点也不了解是不能接受的，所以要简单调查调查。 H5的由来几种定义 h5是HTML的第5级标题标签； H5是在手机上运行的、包含许多动画甚至音乐的纯前端/弱后端页面； h5是2014年10月由W3C制定的HTML新一代标准，其中包含了新标签、新属性、多媒体和本地存储等特性。 H5为什么火？H5是HTML的第5代标准，它不是一个新的应用，不是一个编程语言，甚至不是一个实体(Web应用、微信小程序等)，他就是常规意义上的HTML新版本，和C++17、C++20差不多。HTML等Web应用相关语言和Golang、C++等语言还不一样，它们的标准还需要各大浏览器的运行时支持才算是“真正”拥有了新特性。但是如今大多数用户都能够很方便地通过电脑、手机接触到Web应用，其中不乏动画酷炫、插画精美、音乐好听、让人眼前一亮的应用，开始有人将这样的应用叫做H5，后来逐渐传开再也无法很好地定义了。 普通用户是不会去了解H5到底是什么的，隔行如隔山，弄明白这个对用户来说作用不大。据我观察，各大H5应用模板网站也不会强调这个H5到底是怎么做的，而是统一作为模板打包卖给用户就行。H5可能是纯前端的，也有可能有弱后端，但是“注重呈现”应该是H5的核心，有“动态海报”内味儿。接下俩的H5统一取第二个定义。 H5的组成 H5也是Web应用，那么就离不开HTML、CSS和JavaScript，HTML负责文档结构、CSS负责视觉样式、JS负责业务逻辑，在写H5的时候其实是在写这三种语言。HTML5中的如&lt;canvas&gt;、&lt;audio&gt;、&lt;video&gt;和&lt;svg&gt;等新标签确实为前端的图形渲染提供了良好的载体，但是应用的代码组织与以前差别并不是很大。如今许多浏览器都支持HTML5标准，许多前端程序员也在使用HTML5标准提供的新标签，那么可以说现在只要是写前端都是在写H5。 SPA - 高级H5单页面应用(Single Page Application)的说法最近几年非常流行，前后端分离的开发风格、Web技术和云计算的发展使得浏览器中运行的Web应用无论是开发流程还是使用体验上都越来越接近原生应用(Native Application)。许多SPA的功能全体量大，不输给原生应用。HTML5中提供的本地存储(localStorage)特性相信许多开发者都用过，使用它可以构建相当强大的功能。那么把它叫做高级H5也不过分吧？（doge 另外，如Vuejs、Reactjs等在内的前端开发框架也简化了SPA的开发。 我以前接触过Vuejs和微信小程序，当时觉得微信小程序是大部分借鉴了Vuejs的精髓。前一阵子又看了看Reactjs的文档，发现微信小程序的架构里也能发现Reactjs的影子……虽然React有facebook官方的支持，但是有一说一它的中文文档是真的不行，过时的文档google出来结果竟然还在前列。相比之下Vue虽然没有大公司支持，但是越来越赢得开发者的青睐，其文档的完善也是一大因素吧。 Vue.js: The Documentary最后放上Vue.js的纪录片，赏心悦目。","link":"/2020/06/07/WhatIsH5/"},{"title":"为什么我要写博客？","text":"内外因素我喜欢记录我很喜欢记录，就像首页那句话说的“有着记录的想法，没有记录的时间”一样：我喜欢把生活里有趣的、激发自己思考的事物都记下来，倒不是为了写给谁看或者写给未来的自己看，光是写下来的过程会让我觉得很好，不知道怎么用语言形容的一种“满足感”；但是在学校的时候事情实在是太多了，学习、社工、项目还有各种琐碎的事情让我根本没有时间把所想所见记录下来，所以也就有了这个博客里年更的情况出现了。 2019年的12月31日，我在自己的非主流QQ空间发了一篇名为《别了，我的一零年代》的日志，回顾了一下自己的中学和大学本科时期的得与失，2020年年底实在是太忙了，没能够再写一篇“年终总结”。不过现在想起来也不是很遗憾，因为2020年不是很能激起我的记录欲。好！在！已经研一，兵荒马乱的研一上学期也已经度过了，至少未来一年半内不会有太多课程上的压力，这样可以让我有更多连续的时间能够用来记录。这是让我非常开心的，我猜我今后会多写一些东西在博客上吧，应该会。 我应该记录“学计算机的人应该有一个博客”是我从大学入学时就有的一个想法，这样朴素的情感大概是在我拜读了阮一峰和廖雪峰等大神博客之后就在心里扎根了的。确实，不管是大一入学、大二做课程大作业、大三在校外实习，通过查询和浏览博客是我解决特定问题的主要方式。所以我觉得自己应该也要成为这样的一个“博主”，虽然没有特别亮眼的技术实力，但是通过写博客督促自己不断的学习也是一件足够酷且有益的事情。 还有一件事情值得一提，在写《Github Actions的基本使用》时其实我是边学边写，一开始觉得有个地方是 GitHub Actions 的 Bug ，迫于无奈和夜深，发布博客之后就赶紧溜去睡觉了。第二天回看博客的时候一眼就发现了问题所在，这样的特点也从另一方面激励我继续写博客。 “记录”对我是有好处的。 近期的一点牢骚清华的竞争氛围太强了：每个人都是高中的佼佼者，到了大学有的人依旧游刃有余，有的人就力不从心了，不管排名保持高中的状态还是变好或变坏都是非常正常的事情。找准自己的定位和方向，保持努力就可以了，没有什么比热情更重要。在知乎上经常能看到“清华XX系大四了还一事无成怎么办”这样的问题，如果要我回答的话我确实无法组织出一段话来回答这样的问题，在提问者的上下文里我其实也是一事无成的。 跟人比较确实上头，确实会增加焦虑。可是我不会把自己推到这样的焦虑当中，我不喜欢跟别人比，我只希望自己可以充实和从容，不用妄自菲薄，也不要自以为是。自己只要保持这样的心态和步调就不太在意身边的压力了。 之后写点什么之前有的两个标签是“学习”和“瞎写”，现在觉得“瞎写”有点莫名其妙，之后打算换成“随笔”。有考虑增加一两个标签（例如“游记”和“相册”等），也希望自己能够维持“学习”和其他标签博客的比例。 最后，希望2021年一切都好。 迟到的新年小作文","link":"/2021/01/16/WhyBlog/"},{"title":"从 Vue 到 React —— 第一印象","text":"学习 React 的初衷之前说过想要学习 React，秉持着边学边记录的想法，我随即开启了这篇帖子。 从 Vue 说起我是一个 Vue 的忠实粉丝，虽然没有全部读过 Vue 的源码，但是对它的基本实现原理和大体的使用方法还是比较熟悉的。我自己思考过，我觉得我喜欢 Vue 大概率是因为我最早接触的前端开发框架就是 Vue。记得是 2018 年参加一项 SRT 的时候，为了开发一款简单的后台管理系统，我开始学习 javascript 以及 Vue。 当时我还是第一次接触脚本语言，对没错，我接触 javascript 比接触 python 更早一些。熟悉了 C/C++ 的继承机制之后，突然要接受 javascript 的原型链继承一时间有点缓不过来。但是后来还是被磨平了棱角，被迫接受了原型这一设计。为了开发 Web 应用通过一位学长的介绍接触到了 Vue 这个框架。我直接惊为天人，还能这样写？因为根据我更早之前的一些浅显的印象，Web 开发是分别要编写 HTML，javascript 和 CSS 三种文件的。现在用 Vue 一个文件就可以生成一个完好的页面，着实非常酷炫。也是在 Vue 这里，我了解到了组件、生命周期、全局状态管理、前端路由等等一些重要的概念，所以先入为主地对 Vue 有强烈好感也正常吧。 Vue 的好处就不说了，这里主要想说以下我遇到的问题： 在写 Nuxt 项目写到功能比较重的组件时，一个组件 Vue 文件代码可能会到 800 ~ 900 行，写完 template 后滑滚轮滑到 script 部分找到 methods 里对应的地方写函数，如果模板部分出问题了还得滑回去。文件行数一旦长了，这个上下滑动找代码块的过程真的有点难受，一旦思考过程中出现一小段的空挡，那么就有可能导致思绪完全断掉。 另外，Vue 的代码复用方案我觉得不是特别好：模板方面的槽和脚本方面的混入这两个我觉得不是特别优雅，尤其是混入。混入的文件一旦多了可能会造成组件难以维护的问题，例如不知道模板中使用的某个属性到底是 mixin 中来的还是从 data 或者 props 中来的，如果出现覆盖那么覆盖规则、覆盖后的值又是什么。 插件支持我觉得也没有做得特别好，虽然 Vetur 已经做到相当好了，但有一些情况仍旧是解决不了的，比如上面说的 mixin，其中的属性或者方法就没有办法在调用的页面当中提供补全提醒。 最后，因为总是遇到一些不可名状的 Bug，我打算以后项目的开发要用 typescript，但是 Vue 对 typescript 的支持不是特别好（听说 Vue 3.x 版本有所改善，但是看了一下 Vue3 的文档觉得 composition API 和 React 实在是太像了，不是特别感冒），所以有些打退堂鼓。 总的来说，Vue 的问题不是特别大，我也没有在做很大型很复杂的项目，上面说的小瑕疵不是本质问题（有问题应该也是我自己能力还没到位）。但是总让我觉得有可以更好的地方。 React 哪里吸引我React 是 Facebook 推出的用于构建用户界面的 Javascript 库，应该是目前最热门的“前端框架”，加上引号是因为我觉得它其实不算是一个框架，只是一个“库”，扩展了 js/ts 的语法特性，使它们可以更方便地写 Web 应用。 它很火，看着也很酷，更原汁原味，更轻量化，更自由，有更多的可能性，这应该就是我想了解它的原因吧。 对 React 的第一印象读了一下官方的入门教程，React 给我印象最深的有下面几个方面： 完全使用 js/ts 编写，没有增加新的文件类型，在 vscode 中编码体验良好（jsx/tsx 不太算新类型吧）； state 与普通属性区别开来，如果需要更新需要显式的调用 setState 方法，虽然牺牲了一定的灵活性，但是也一定程度上促进了数据的安全访问；同时，这样近于“严苛”的 state 更改方法会鼓励开发者将组件拆分成更小的部分； 提供函数组件和类组件两种写法，函数组件的写法可以省很多空间； React Hooks 看起来像是 Vue Composition API 的原型，函数组件用起来会比较“优雅”； JSX 渲染函数的写法可以将实现某功能项的代码尽可能的收缩到同一个空间区域，拥有更好的空间“局部性”，免于在 template 和 script 之间来回切换打断思路的困扰； 阿里的 Ant Design 为 React 前端开发提供了一个很好的组件库和设计规范，不得不说，阿里对优化用户体验真的有很深入的研究。 之后探索的方向但是其实前端框架归根结底做的事情都是一样的，是让开发者能够较为轻松地开发出易于测试、易于维护、方便拓展、体验良好的跨平台的 Web 应用。不管是之前写 Vue 代码还是之后要写的 React 的代码，都是为了这样一个同样的目的。然而如果仅仅光想着实现功能而不去思考更多，很容易陷入为写代码而写代码的陷阱当中。 因为我在实验室课题组里负责了几个项目，几乎每个项目都是不超过3人的小团队。如果开发周期稍微变长一些，项目的功能就会变得异常复杂，而作为开发者，在测试的时候很容易就会局限在正常（或者说正确的）业务逻辑当中，不会发现一些匪夷所思的问题。（感觉真的很难让一个要写正确逻辑业务代码的开发者去做一些极不符合预期的事情。）测试很重要。只要不是自己小打小闹的学习性质地写着玩儿，测试就是极其重要的。测试保障的是软件的质量，在任何有甲方的项目当中，没有进行详尽测试都是不负责的。在写后端代码的时候，测试起来比较容易，因为提供的 API 是可预期的，传入什么样的参数，返回什么样的响应，都是清清楚楚的。至少对于开发者自己来说，后端代码都是白盒，将单元测试覆盖率提高就可以显著地提高代码的可靠程度。那么前端测试呢？ 前端测试中主要有单元测试、组件测试和端到端测试。单元测试其实并不区分写的是前端还是后端的代码，都是追求更高的代码覆盖率。而组件测试和端到端测试可能对于前端应用来说更重要吧，因为前端应用给用户操作的组合是无限的，用户可以选择以任何路径，触发页面任何元素可能的动作，想要详尽地测试属实比较困难，但是组件测试和端到端测试应该都是比较成熟的测试方案，能够在一定程度上提高应用的可靠程度。 之后除了继续接触 React 之外，我还会去了解一些组件测试和端到端测试的最佳实践，扩充一下自己的前端知识储备。","link":"/2021/03/27/Vue2React-1/"}],"tags":[{"name":"前端开发","slug":"前端开发","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"摄影","slug":"摄影","link":"/tags/%E6%91%84%E5%BD%B1/"},{"name":"旅游","slug":"旅游","link":"/tags/%E6%97%85%E6%B8%B8/"},{"name":"Misc","slug":"Misc","link":"/tags/Misc/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"文档阅读","slug":"文档阅读","link":"/tags/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/"},{"name":"论文阅读","slug":"论文阅读","link":"/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"胡思乱想","slug":"胡思乱想","link":"/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}